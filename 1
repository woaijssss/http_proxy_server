
#ifndef __UTIL_H__
#define __UTIL_H__

#include <string>
#include<typeinfo>

void exitService(int status);

/* 毫秒级延迟 
 */
void delayMs(const unsigned int& ms);

/* string字符型转成十六进制，用于打印原始数据
 */
std::string getHexString(unsigned char* s, const int& len);

/* 初始化所有配置文件
 */
void initConfig();

#define GET_PARAM_TYPE(__x) typeid(__x).name()


#endif  // __UTIL_H__

#ifndef __WHPS_CONN_SOCKET_H__
#define __WHPS_CONN_SOCKET_H__

#include "Socket.h"

/* 客户端连接socket类，保留客户端的连接信息
 */
class WHPSConnSocket : public Socket
{
public:
        //WHPSConnSocket();
        WHPSConnSocket(int fd);
        virtual ~WHPSConnSocket();

public:
        /* 检查句柄是否有效 */
        bool isValid();

        /* 获取当前socket句柄 */
        const int& get() const;

        /* 设置客户端socket，用于在主socket Accept后设置 */
        void set(int fd);

        /* 设置非阻塞socket */
        int setNonblock();

        /* 设置socket属性 */
        int setOption();

        /* 关闭socket */
        int close();

private:
};

#endif  // __WHPS_CONN_SOCKET_H__

#ifndef __WHPS_EPOLL_EVENT_LOOP_H__
#define __WHPS_EPOLL_EVENT_LOOP_H__

/* 事件循环类，核心功能为等待epoll事件的返回
 * 该任务由工作线程来执行
 * 若有事件返回，回调到外部callback中。
 */
#include "WHPSPoller.h"
#include "vector.h"
#include "Task.h"

class WHPSEpollEventLoop
{
public:
        using task_t = std::function<void()>;   // 线程任务队列的任务类型(应与ImplThread中的任务类型相同)
public:
        WHPSEpollEventLoop(int maxevents = 1024, int timeout = 100);
        ~WHPSEpollEventLoop();

public:
        /* 添加事件 */
        void addEvent(event_chn* p_event);

        /* 移除事件 */
        void delEvent(event_chn* p_event);

        /* 修改事件 */
        void updateEvent(event_chn* p_event);

        /* 核心：事件循环任务 
         * 所有工作线程都应工作在此(包括主线程和子线程)
         *   - 主线程：用于接收、断开客户端连接；
         *   - 子线程：用于接收、发送客户端数据；
         */
        void loop();

        /* 子线程执行，循环由线程控制，函数内部只执行一次 */
        void loopOne();      

        /* 获取当前循环的任务队列 */
        Task<task_t>& getTask();

        /* 通过事件处理，添加一个异步任务 */
        void addTask(task_t func_cb);

public:         // 测试接口
        void stop();

private:
        WHPSPoller _poller;                     // 事件轮询对象

        /* 事件队列 
         * 外部线程，通过事件队列，来向epoll获取任务
         */
        Vector<event_chn*> _event_queue;

        bool _is_stop;

        Task<task_t> _task;     // 线程任务队列
};

#endif  // __WHPS_EPOLL_EVENT_LOOP_H__
/*
 * WHPSEpollThread.h
 *
 *  Created on: Jul 7, 2019
 *      Author: wenhan
 */

#ifndef __WHPSEPOLLTHREAD_H__
#define __WHPSEPOLLTHREAD_H__

class WHPSEpollThread
{
public:
        WHPSEpollThread();
        ~WHPSEpollThread();

public:
        /* 启动线程 */
        void start();

private:

};

#endif /* __WHPSEPOLLTHREAD_H__ */

#ifndef __WHPS_EVENT_HANDLER_H__
#define __WHPS_EVENT_HANDLER_H__

#include <mutex>

#include "ImplEventHandler.h"
#include "WHPSTcpSocket.h"

class WHPSEventHandler;

typedef ImplEventHandler::__callback_t CbFunc;
typedef ImplEventHandler::__epoll_events_t events_t;
typedef WHPSEventHandler event_chn;

enum EventType
{

};

/* 事件注册、回调类：
 *  （1）设置指定的fd
 *  （2）设置指定的epoll触发类型
 *  （3）设置指定的回调函数
 */
class WHPSEventHandler : public ImplEventHandler
{
public:
        WHPSEventHandler();
        virtual ~WHPSEventHandler();

public:
        /* 设置当前处理的句柄描述符 */
        void setFd(const int& fd);

        /* 获取已设置的句柄描述符 */
        const int& getFd();

        /* 设置epoll事件类型宏 */
        void setEvents(events_t events);

        /* 获取epoll事件类型宏 */
        const events_t& getEvents() const;

        /* 设置读事件回调函数 */
        void setReadCallback(CbFunc cb);

        /* 设置写事件回调函数 */
        void setWriteCallback(CbFunc cb);

        /* 设置错误事件回调函数 */
        void setErrorCallback(CbFunc cb);

        /* 设置关闭句柄事件回调函数 */
        void setCloseCallback(CbFunc cb);


        /* 执行事件回调函数 */
        virtual void exCallback();

private:
        /* 设置事件回调函数：
         *      任何设置事件回调的过程，都通过此接口实现；
         * 禁止外部回调
         */
        virtual void setCallback(CbFunc& cb_s, CbFunc cb_d);

        virtual void __stdcall __setCallback(__callback_t& __cb_s, __callback_t __cb_d);

        /* 执行回调函数接口 */
        virtual void __stdcall __exCallback();

        void onCall(CbFunc cb);

private:
        CbFunc _cb_read;      // 读回调
        CbFunc _cb_write;     // 写回调
        CbFunc _cb_error;     // 错误回调
        CbFunc _cb_close;     // 关闭回调

        std::mutex _mutex;
};

#endif  // __WHPS_EVENT_HANDLER_H__

#ifndef __WHPS_IMPL_MACRO_BASE_H__
#define __WHPS_IMPL_MACRO_BASE_H__

/* 宏定义 */
/*
 * 从字符串获取需要的内容
 */
#define Impl_GET_CONTENT(TypeName, ResType)                     \
        inline ResType GetContent(const std::string& sstr)      \
        {                                                       \
                return Get##TypeName(sstr);                     \
        }

#define Impl_GET_KV_SPLIT(KvType, __sep)                                \
        inline void GetSplit(KvType& st, const std::string& sstr)       \
        {                                                               \
                return GetKvSplit(st, sstr, __sep);                     \
        }

#define Impl_GET_CONTACT(dstType, srcType, __crlf)                      \
        inline bool GetContact(dstType& dt, srcType& st)                \
        {                                                               \
                return GetContactContent(dt, st, __crlf);               \
        }

#endif  // __WHPS_IMPL_MACRO_BASE_H__
#ifndef __WHPS_POLLER_H__
#define __WHPS_POLLER_H__

#include "WHPSEventHandler.h"
#include "Poller.h"

#include "map.h"
#include "vector.h"

#define MAX_EVENTS      1024            // 最大触发的事件数

/* WHPS事件循环基础类，用于启动事件和对事件的增、删、改、查。
 * WHPSPoller中，维护事件列表、事件队列等。
 */
class WHPSPoller : public Poller
{
public:
        using OpsType = unsigned int;
        enum OPSTYPE
        {
                ADD = 0,
                DEL,
                UPDATE
        };
public:
        WHPSPoller(int maxevents, int timeout);
        ~WHPSPoller();

public:         // 外部调用
        /* 启动epoll任务 */
        int poll(Vector<event_chn*>& event_queue);

        /* 添加到事件通知列表 */
        void addEvent(event_chn* p_event);

        /* 从事件通知列表移除 */
        void delEvent(event_chn* p_event);

        /* 修改事件 */
        void updateEvent(event_chn* p_event);

        /* 设置事件等待超时时间 */
        void setTimeout(int timeout);

private:        // 内部调用

        void eventOperation(OpsType type, event_chn* p_event);
        /* 新增一个事件到事件列表 */
        void addToEventList(int fd, event_chn* p_event);

        /* 从事件列表中删除一个事件 */
        void delFromEventList(int fd);

        /* 更新事件列表中已存在的一个事件 */
        // void updateEventList(int fd);

        /* 等待事件触发 */
        int epollWait();

        /* 向队列中添加已触发的事件，提交给外部线程处理 */
        void onEvent(Vector<event_chn*>& event_queue, const int& n_fds);
private:
        Map<int, event_chn*> _event_list;      // 事件列表 <fd, WHPSEventHandler*>
        SEplEvent _events[MAX_EVENTS];
};

#endif  // __WHPS_POLLER_H__

#ifndef __WHPSSOCKET_H__
#define __WHPSSOCKET_H__

#include "Socket.h"

#define SERVER_MODE             0       // 服务器主socket
#define CLIENT_CONN_MODE        1       // 服务器接受连接的客户端的socket

/*
 * WHPS服务的基础socket类，初始化服务
 */

class WHPSSocket : public Socket
{
public:
        WHPSSocket(int mode);
        virtual ~WHPSSocket();

public:
        /* 设置socket，适用于服务器接收的客户端socket */
        void set(int fd);

        /* 初始化socket属性，确定socket模式 */
        int init();

        /* 服务器模式socket初始化 */
        int initServerMode();

        /* 连接客户端的socket初始化 */
        int initClientConnMode();

        /* 获取当前socket句柄 */
        const int& get() const;

protected:

        /* 设置socket属性 */
        int setSocketOpt();

        /* 设置非阻塞socket */
        int setNonblock();

        /* 创建一个socket */
        int socket();

        /* 绑定一个端口
         *      server模式：ip地址无需传递
         *      client模式：ip地址需传指定的服务器ip
         */
        int bind(const int& port, const char* ip = NULL);

        /* 启动监听 */
        int listen();

        /* 获取被监听的连接请求 */
        int accept();   // 暂时不用
        int accept(struct sockaddr_in& c_addr);         // 优先实现这个接口
        //struct sockaddr_in accpet();    // 暂时不用

        /* 设置socket地址重用(主要用于服务端socket) */
        int setReuseAddr();

        /* 关闭socket */
        int close();

private:
        int _mode;
        int _tcp_port;   // tcp监听端口
};

#endif 	// __WHPSSOCKET_H__

#ifndef __WHPSTCPSERVER_H__
#define __WHPSTCPSERVER_H__

#include "WHPSTcpSocket.h"
#include "WHPSEventHandler.h"
#include "WHPSEpollEventLoop.h"
#include "WHPSTcpSession.h"
#include "WHPSThreadPool.h"

#include "ImplSingleton.h"
#include "SingletonRegister.h"
#include <memory>
#include <iostream>

/* Tcp服务类
 * 单例模式： 一个服务进程只能有一个主socket
 */
class WHPSTcpServer : public ImplSingleton<WHPSTcpServer>
{
public:
        using error_code = unsigned int;
        using sp_TcpSession = WHPSTcpSession::sp_TcpSession;
        using cbFunc = std::function<void(const sp_TcpSession&)> ;
public:
        WHPSTcpServer();
        /* 虽然是单例，但实例化了线程池，没有析构函数，服务停止时，无法正常释放线程资源，导致内存泄漏 */
        virtual ~WHPSTcpServer();

        /* 获取单例实例 */
        static WHPSTcpServer* GetInstance();

        /* 应用侧检查句柄是否有效 */
        bool isValid();

        /* 获取服务器主socket */
        WHPSTcpSocket& getSocket();

        /* 启动tcp服务，包含：
         *      - 启动WHPSEpollEventLoop事件循环；
         *      - 设置epoll触发类型
         *      - 注册相关回调函数
         * 若启动失败(即：返回false)，则服务无效，重启服务即可。
         */
        bool start();

        /* 开启事件循环 */
        void startLoop();

        /* 获取主socket事件循环对象 */
        WHPSEpollEventLoop& loop();

private:
        /* 接收新建连接的回调函数 */
        void onNewConnection(error_code error);

        /* 处理新建连接，设置相关属性，并加入到_loop事件循环中 */
        void onNewSession();

public:
        /* 某个客户端连接关闭时，调用此回调清除句柄资源 */
        void onCleanUpResource(const sp_TcpSession& sp_tcp_session);

public:     // 应用层回调注册接口
        /* 客户端连接回调 */
        void setNewConnCallback(cbFunc cb);

        /* 客户端断开回调 */
        void setNewCloseCallback(cbFunc cb);

public:     // 测试接口
        void stop()
        {
                _loop.stop();
        }

private:
        // static WHPSTcpServer* _tcp_server;
        static std::shared_ptr<WHPSTcpServer> _tcp_server;

        WHPSEpollEventLoop _loop;       // 服务器事件循环触发
        WHPSThreadPool _thread_pool;    // 线程池句柄
        WHPSTcpSocket _tcp_socket;      // 服务器主socket
        WHPSEventHandler _event_chn;    // 服务器事件回调通道

        /* 保证在连接存在时，智能指针至少被引用一次，不至于销毁连接 */
        Map<int, sp_TcpSession> _tcp_sess_list;   // tcp客户端连接表(断线要清理)

private:    // 应用层回调函数
        cbFunc _cb_connect;     // 新连接应用层回调
        cbFunc _cb_close;       // 连接关闭应用层回调
};

GET_SINGLETON_OBJECT_PTR(WHPSTcpServer)

#endif  // __WHPSTCPSERVER_H__

#ifndef __WHPS_TCP_SESSION_H__
#define __WHPS_TCP_SESSION_H__

#include <memory>
#include <mutex>

#include "WHPSConnSocket.h"
#include "WHPSEventHandler.h"
#include "WHPSEpollEventLoop.h"

/* 连接客户端表示类，该类实例化的每个对象，分别表示一个客户端的一条tcp连接
 * 句柄的操作由WHPSTcpConnSocket来维护；
 * 该类不做socket的改变
 */
class WHPSTcpSession : public std::enable_shared_from_this<WHPSTcpSession>
{
public:
        using error_code = unsigned int;
        using sp_TcpSession = std::shared_ptr<WHPSTcpSession>;
        using TcpSessionCB = std::function<void(const sp_TcpSession&)>;

        // 应用层回调函数类型
        using httpCB = std::function<void()>;
public:
        WHPSTcpSession(WHPSEpollEventLoop& loop, const int& fd, struct sockaddr_in& c_addr);
        ~WHPSTcpSession();

        std::string& getBufferIn()
        {
                return _buffer_in;
        }

        const std::string& getBufferOut()
        {
                return _buffer_out;
        }

public:
        /* 获取对端网络信息：
         *    ip、端口等
         */
        void getEndpointInfo();

        /* 获取客户端ip */
        const std::string& getIp() const;

        /* 获取客户端端口 */
        const int& getPort() const;

        /* 获取客户端网络信息
         * 格式为：
         *      ip:port
         */
        const std::string& getNetInfo() const;


        /* 检查句柄是否有效 */
        bool isValid();

        /* 获取当前socket句柄 */
        const int& get() const;

        /* 获取当前连接信息句柄 */
        WHPSConnSocket& getConn();

        /* 主动关闭连接 */
        void close();

        /* 将当前的客户端session的事件回调通道，加入到EventLoop事件循环中 */
        void addToEventLoop();

        /* 移除事件 */
        void delFromEventLoop();

        /* 设置资源清理回调函数
         * 由于socket是从主socket申请的资源，主socket和EventLoop都有记录，
         * 因此，需要设置该回调函数。
         * 在socket触发close()时，该函数会回调到主socket中，进而清理socket资源。
         */
        void setCleanUpCallback(TcpSessionCB& cb);

        /* 写数据要触发epoll事件 */
        void send(const std::string& msg);

public:         // 应用层回调函数设置
        /* http接收数据回调函数 */
        void setHttpMessageCallback(httpCB cb);

        /* http发送数据回调函数 */
        void setHttpSendCallback(httpCB cb);

        /* http连接关闭回调函数 */
        void setHttpCloseCallback(httpCB cb);

        /* http异常错误回调函数 */
        void setHttpErrorCallback(httpCB cb);

        void setProcessingFlag(bool is_processing);

        const bool& getProcessingFlag() const;

private:

        /**********************************************************************/
                // 当前读、写异常情况处理可能不全面，后续出问题再追加
        /* 写数据要触发epoll事件，必须要主动先写一次，调用此接口
         * 由send()调用
         */
        int sendTcpMessage(std::string& buffer_out);

        /* 真正的读read()操作，由onNewRead() epoll事件触发后调用 
         * 由onNewRead()调用
         */
        int readTcpMessage(std::string& buffer_in);
        /**********************************************************************/

        /**********************************************************************/
                // error_code字段值为预留，后续扩展要加入异常
        /* 接收数据事件处理回调 */
        void onNewRead(error_code error);

        /* 发送数据事件处理回调 
         * 该接口的实现中，应检测数据是否发送完毕，并将剩余数据递归发送完成。
         */
        void onNewWrite(error_code error);

        /* 关闭连接事件处理回调 */
        void onNewClose(error_code error);

        /* 异常错误事件处理回调 */
        void onNewError(error_code error);

        void onCall(httpCB cb);
        /* 清除当前session的所有资源
         * 包括：
         * （1）所有回调函数指针置空
         * （2）socket关闭
         * （3）buffer缓存清空
         */
        void release();
        /**********************************************************************/

private:    // 网络层各对象
        struct sockaddr_in _c_addr;     // 保存客户端的连接信息
        WHPSEpollEventLoop& _loop;      // 引用外部事件循环
        WHPSConnSocket _conn_sock;      // 连接句柄
        event_chn _event_chn;           // 服务器事件回调通道
        events_t  _base_events;         // 连接默认的事件监听标识

        TcpSessionCB _cb_cleanup;

private:    // 对应用服务层提供的可用数据
        std::string _client_ip;         // 客户端ip
        int _client_port;               // 客户端端口
        std::string _net_info;          // 客户端网络信息(格式：   ip:port)
        
        std::string _buffer_in;         // 接收消息缓冲(tcp请求)
        std::string _buffer_out;        // 发送消息缓冲(tcp响应)

        bool _is_connect /*= true*/;    // 连接标志(默认为true)

        bool _is_processing;             // 数据处理标志
        bool _is_wait;

private:        // 应用层回调函数定义
        httpCB _http_onMessage;            // http接收数据回调函数
        httpCB _http_onSend;            // http发送数据回调函数
        httpCB _http_onClose;           // http连接关闭回调函数
        httpCB _http_onError;           // http异常错误回调函数

        std::mutex _mutex;
};

typedef WHPSTcpSession::TcpSessionCB    TcpSessionCB;

#endif  // __WHPS_TCP_SESSION_H__

#ifndef __WHPSTCPSOCKET_H__
#define __WHPSTCPSOCKET_H__

#include "WHPSSocket.h"
// #include "WHPSConnSocket.h"

#include <iostream>

/* WHPS服务主socket类
 */
class WHPSTcpSocket : public WHPSSocket
{
public:
        WHPSTcpSocket(int mode);
        virtual ~WHPSTcpSocket();

        /* 应用侧检查句柄是否有效 */
        bool isValid();

        /* 主socket接收客户端连接
         * 返回一个客户端socket对象
         */
        int Accept(struct sockaddr_in& c_addr);
private:
};

#endif  //__WHPSTCPSOCKET_H__

#ifndef __WHPS_THREAD_H__
#define __WHPS_THREAD_H__

#include "WHPSEpollEventLoop.h"
#include "CPPThread.h"

class WHPSThread
{
public:
        using task_func_t = CPPThread::impl_task_func_t;
        using task_t = CPPThread::task_t;
public:
        WHPSThread(Task<task_t>& task);
        ~WHPSThread();

public:
        void start();

        void stop();

        WHPSEpollEventLoop& getLoop();

private:
        void workFunc();

        void excuteTask();
private:
        CPPThread _thrd;
        bool _is_stop;
        WHPSEpollEventLoop _loop;
};

#endif  // __WHPS_THREAD_H__
#ifndef __WHPS_THREAD_POOL_H__
#define __WHPS_THREAD_POOL_H__

#include "WHPSEpollEventLoop.h"
#include "ImplThreadPool.h"
#include "WHPSThread.h"

class WHPSThreadPool : public ImplThreadPool
{
public:
        /* 线程池入口，可设置工作线程数量 */
        explicit WHPSThreadPool(int size, WHPSEpollEventLoop& main_loop);
        explicit WHPSThreadPool(int size, WHPSEpollEventLoop& main_loop, task_func_t callback);    // 可以设置线程的执行函数
        
        ~WHPSThreadPool();

public:
        WHPSEpollEventLoop& getOneLoop();

        /* 所有线程开始执行任务 */
        void start();

private:
        /* 创建一定数量的线程 */
        void createThreads();

        /* 所有线程停止执行任务，释放资源并退出 */
        void stop();

private:
        WHPSEpollEventLoop& _main_loop;         // 主循环(单线程时使用)
        int _index;
        int _size;     // 线程数量
        task_func_t     _callback;             // 记录线程的执行函数
        std::vector<WHPSThread*> _v_th;        // 线程列表

        Task<task_func_t> _task;          // 线程任务(当前是所有线程共享一个任务队列)
};

#endif  // __WHPS_THREAD_POOL_H__
#ifndef __HTTP_WHPS_H__
#define __HTTP_WHPS_H__

#include "WHPSHttpParser.h"

typedef struct HttpRequestContext       HttpWhpsRequest;        // http请求信息
typedef struct HttpResponseContext      HttpWhpsResponse;       // http响应信息

/* WHPS http服务最上层（业务层）虚类
 * 所有实现http应用开发，都要继承于此，通过配置文件来配置以下信息：
 *      （1）类文件路径
 */
class HttpWhps
{
public:        
        HttpWhps()
        {

        }

        virtual ~HttpWhps()
        {

        }

public:
        /* GET/DELETE 方法的请求处理 */
        virtual void doGet(HttpWhpsRequest request, HttpWhpsResponse response) = 0;

        /* POST/PUT 方法的请求处理 */
        virtual void doPost(HttpWhpsRequest request, HttpWhpsResponse response) = 0;
        // void doPut(HttpWhpsRequest request, HttpWhpsResponse response);
        // void doDelete(HttpWhpsRequest request, HttpWhpsResponse response);
private:
};

#endif  // __HTTP_WHPS_H__
#ifndef __WHPS_HTTP_PARSER_H__
#define __WHPS_HTTP_PARSER_H__

#include <map>

#include "String.h"
#include "WHPSRequest.h"
#include "WHPSResponse.h"

/* HTTP请求报文解析
 *  主要功能：
 *      （1）解析http请求url
 *      （2）解析http请求头
 *      （3）解析http请求body（GET和DELETE时，body应为空）
 *      （4）将解析后的资源信息、请求头、请求体合成一个大的结构体，返回给外部调用
 */
/* class WHPSHttpParser; */
class WHPSHttpParser
{
public:
        using SpVector = String::SVector;       // SplitVector

        WHPSHttpParser();
        ~WHPSHttpParser();

public:
        /* 从原始数据解析出http各项参数 */
        void parseHttpRequest(std::string& raw_msg, HttpRequestContext& context);

private:        
        /* 以下为各部分的解析方法，参数必须包含行序列和请求内容结构，
         * 每一步骤，自行补全"请求内容"结构中的相关值
         */
        /* 解析的第一步：
         *      从原始数据，按每一行拆分出行序列，并按行提取数据
         */
        void parseSequence(SpVector& vrow_seq, HttpRequestContext& context);

        /* 第一行(请求行)要特殊处理 */
        bool getFirstLine(SpVector& vrow_seq, HttpRequestContext& context);

        /* 提取第一行请求后，根据url格式来判断请求的是否是静态资源；
         * 如果是静态资源，无需调用至用户应用层，在系统层直接返回资源文件；
         * 如果不是静态资源，则需要调用至用户层，并通过用户开发的应用程序返回相应的资源。
         */
        bool checkResourceType(const std::string& url);

        /* 获取http请求头信息 */
        void getHeaderInfo(SpVector& vrow_seq, HttpRequestContext& context);

        /* 获取http请求体信息 */
        bool getBodyInfo(SpVector& vrow_seq, HttpRequestContext& context);

private:
        const char* _crlf_old/* = "\n"*/;   // 兼容老版本或不完整的http，提高兼容性(详见协议)
        const char* _crlf/* = "\r\n"*/;   // 标准http请求行，都是以"\r\n"结尾分割
};

#endif  // __WHPS_HTTP_PARSER_H__
#ifndef __WHPS_HTTP_SERVER_H__
#define __WHPS_HTTP_SERVER_H__

#include "ImplSingleton.h"
#include "WHPSTcpServer.h"
#include "WHPSHttpSession.h"

/* HTTP服务的核心类
 * 启动http服务、设置数据回调接口、创建httpsession等操作
 * 单例模式： 一个服务进程只能有一个HTTP服务
 */
class WHPSHttpServer : public ImplSingleton<WHPSHttpServer>
{
public:
        using sp_TcpSession = WHPSTcpServer::sp_TcpSession;
        using sp_HttpSession = WHPSHttpSession::sp_HttpSession;
public:
        WHPSHttpServer();
        virtual ~WHPSHttpServer();

public:
        /* 获取单例对象句柄 */
        static WHPSHttpServer& GetInstance();

        /* 启动http服务 */
        void start();

public:         // 测试接口
        void stop()
        {
                _tcp_server->stop();
        }

private:        // 业务函数
        /* 接收新建连接的回调函数 */
        void onNewConnection(const sp_TcpSession& tcp_session);

        /* 处理新建连接，创建http session，并设置tcp session对应于http session的回调函数
         * 应由 onNewConnection() 内部调用
         */
        void onNewSession(const sp_TcpSession& tcp_session);

        /* 连接断开回调函数 */
        void onNewClose(const sp_TcpSession& tcp_session);

public:     // 后面需要增加一些接口，用来进行外部监控（比如：当前http有效连接数等）

private:
        // static WHPSHttpServer* _http_server;
        static std::shared_ptr<WHPSHttpServer> _http_server;
        WHPSTcpServer* _tcp_server;

        Map<std::string, sp_HttpSession> _http_sess_list;    // http列表
};

GET_SINGLETON_OBJECT(WHPSHttpServer)

#endif  //

#ifndef __WHPS_HTTP_SESSION_H__
#define __WHPS_HTTP_SESSION_H__

#include <string>

#include "WHPSTcpSession.h"
#include "WHPSHttpParser.h"
#include "HttpWhpsFactory.h"
#include "HttpWhps.h"   // for aplication layer call
#include "HttpWriterRegistser.h"

/* 系统静态资源处理器（不应对外可见，后面放到源文件里）
 */
class WhpsSysResource: public HttpWhps
{
public:
        WhpsSysResource(const std::string& rootPath);

        virtual ~WhpsSysResource();

public:
        virtual void doGet(HttpWhpsRequest request, HttpWhpsResponse response);

        virtual void doPost(HttpWhpsRequest request, HttpWhpsResponse response) {}

private:
        /* 处理静态资源请求 */
        void getResouceFile(const std::string& path, std::string& msg);

private:
        const std::string& _rootPath;   // 静态资源根目录
};

/* http session：单个http连接，基于tcp session的tcp连接，二者为强依赖关系
 * HttpSession的实例化，必须依赖于TcpSession；
 * 
 * （1）应用层的数据处理，入口应是：
 *      WHPSHttpSession::onHttpRecv()
 */
class WHPSHttpSession
{
public:
        using sp_TcpSession = WHPSTcpSession::sp_TcpSession;
        using sp_HttpSession = std::shared_ptr<WHPSHttpSession>;
        // using HttpSessionCB = std::function<void(const sp_HttpSession&)>;
        using HttpSessionCB = std::function<void()>;
        using HttpSessionCB_ = std::function<void(const sp_TcpSession&)>;
        using WriterFunc = HttpWriterRegistser::cbFunc;
        using HttpPtrType = HttpWhpsFactory::HttpPtrType;
public:
        /* http session的实例化，必须依赖于tcp session，是一一对应的关系 */
        WHPSHttpSession(const sp_TcpSession tcp_session);

        ~WHPSHttpSession();

public:
        /* 获取当前http连接对应的tcp连接 */
        const sp_TcpSession& getTcpSession() const;

        /* 设置http连接回调函数，提供HttpServer当前释放的http session */
        void setHttpCloseCallback(HttpSessionCB_ cb);

private:
        /* http接收消息回调 */
        void onHttpMessage();

        /* 消息回调处理程序 */
        void onCallback(HttpRequestContext& request, HttpResponseContext& response);

        /* 静态资源请求处理 */
        void onStaticRequest(HttpRequestContext& request, HttpResponseContext& response);

        /* 动态资源请求处理 */
        void onDynamicRequest(HttpRequestContext& request, HttpResponseContext& response);

        /* http发送消息回调 */
        void onHttpSend();

        /* http连接关闭回调 */
        void onHttpClose();

        /* http异常错误回调 */
        void onHttpError();

private:
        /* http层根据Connection字段值，来判断是否通知tcp层
         * 发送数据后断开连接，作通知功能。
         */
        void notifyToClose();

private:        // writer
        /* 客户端回写接口
         */
        void sendHttpMessage(const std::string& msg);

private:
        // 先使用这种方式测试http功能，后续引入工作线程池后，可以将发送消息的任务，加入到工作线程队列里
        const sp_TcpSession _tcp_session;      // tcp连接对象
        HttpSessionCB_ _http_closeCB;            // http连接断开回调函数

        WHPSHttpParser _http_parser;            // http解析器

private:
        const std::string& _obj_name;           // 配置文件中，配置的子类名称
        WhpsSysResource _whps_static_processor; // 系统静态资源处理器
        HttpWhpsFactory* _http_whps_factory;    // 应用层实例化工厂类对象
        // HttpWhps* _http_whps;                        
        HttpPtrType _http_whps;                 // 应用层（业务层）调用句柄


        WriterFunc _writer_func;
        HttpWriterRegistser _writer;   // 数据发送注册器
};

#endif  // __WHPS_HTTP_SESSION_H__

#ifndef _WHPS_OBJECT_H__
#define _WHPS_OBJECT_H__

#include <typeinfo>
#include <memory>

#include "WhpsObjRegisterBase.h"
#include "HttpWhpsFactory.h"

template<class T>
class WhpsObject : public WhpsObjRegisterBase, public HttpWhps
{
public:
        using HttpPtrType = HttpWhpsFactory::HttpPtrType;
public:
        // static WhpsObjRegisterBase * CreateObject()
        static HttpPtrType CreateObject()
        {
                // return new T();
                HttpPtrType ptr(new T());
                return ptr;
        }
 
        struct Aux
        {
                Aux()
                {
                        if (!GetHttpWhpsFactory()->regist(typeid(T).name(), CreateObject))
                        {
                                cout << "regist failed" << endl;
                        }
                }

                inline void do_nothing()const { }
        };
 
        static Aux _aux;        // 类名注册辅助器
 
public:
        WhpsObject()
        {
             
        }
 
        virtual ~WhpsObject()
        {
                _aux.do_nothing();
        }
};

template <class T>
typename WhpsObject<T>::Aux WhpsObject<T>::_aux;

#endif  // _WHPS_OBJECT_H__

#ifndef __WHPS_REQUEST_H__
#define __WHPS_REQUEST_H__

#include "WHPSRequestWrapper.h"

/* http请求类实体 */
struct HttpRequestContext: public WHPSRequestWrapper
{
public:
        HttpRequestContext();
        virtual ~HttpRequestContext();

public:
        /* 获取请求方法 */
        const std::string&    getMethod();

        /* 获取请求uri路径 */
        const std::string&    getUrl();

        /* 获取请求客户端的http版本信息 */
        const std::string&    getVersion();

        /* 获取所有请求消息头 */
        HttpRequestHeader&    getHeader();

        /* 获取请求消息体 */
        const std::string&    getBody();

        /* 获取当前请求的是否为静态资源标识 */
        const bool&           getFlag();

        void setMethod(const std::string& method);
        void setUrl(const std::string& url);
        void setVersion(const std::string& version);
        void setHeader(const std::string& k, const std::string& v);
        void setBody(const std::string& body);
        void setFlag(const bool& flag);
};

#endif  // __WHPS_REQUEST_H__
#ifndef __WHPS_REQUEST_WRAPPER_H__
#define __WHPS_REQUEST_WRAPPER_H__

#include <map>
#include <string>

typedef std::map<std::string, std::string>  HttpHeader__;
typedef std::string                         HttpBody__;
#define HttpRequestHeader       HttpHeader__
#define HttpRequestBody         HttpBody__

class WHPSRequestWrapper
{
public:
        WHPSRequestWrapper();
        virtual ~WHPSRequestWrapper();
protected:
        /* 获取请求方法 */
        const std::string&       _getMethod();

        /* 获取请求uri路径 */
        const std::string&       _getUrl();

        /* 获取请求客户端的http版本信息 */
        const std::string&       _getVersion();

        /* 获取所有请求消息头 */
        HttpRequestHeader&       _getHeader();

        /* 获取请求消息体 */
        const std::string&       _getBody();

        /* 获取当前请求的是否为静态资源标识 */
        const bool&              _getFlag();

protected:void _setMethod(const std::string& method);
        void _seturl(const std::string& url);
        void _setVersion(const std::string& version);
        void _setHeader(const std::string& k, const std::string& v);
        void _setBody(const std::string& body);
        void _setFlag(const bool& flag);
        
private:
        std::string             _method;        // 请求方法
        std::string             _url;           // 请求资源路径
        std::string             _version;       // 协议版本
        HttpRequestHeader       _header;        // 请求头(K-V格式)
        std::string             _body;          // 请求体

        bool                    _isStatic;      // 是否是静态资源
};

#endif  // __WHPS_REQUEST_WRAPPER_H__
#ifndef __WHPS_RESPONSE_H__
#define __WHPS_RESPONSE_H__

#include "WHPSResponseWrapper.h"

class WHPSHttpSession;
/* http响应类实体 */
struct HttpResponseContext: public WHPSResponseWrapper
{
public:
        using cbFunc = WHPSResponseWrapper::cbFunc;
private:
        HttpResponseContext& getResponse();

public:
        HttpResponseContext(cbFunc cb);

        virtual ~HttpResponseContext();

public:
        WhpsWriter& getWriter();

public:         /* 标准响应头函数*/
        /* 设置http响应包体长度 */
        void setContentLength(const std::string& length);

        /* 设置http响应内容类型 */
        void setContentType(const std::string& type);

//-----------------------------------------------------------------------------------
public:         /* 以下是添加自定义响应头和时间的函数 */
        /* 该方法是设置有多个值的响应头,参数name表示响应头名称,参数value表示响应头的值 
         */
        void addHeader(const std::string& h_key, const std::string& h_value);

        /* 该方法是设置有多个值且值的类型为int类型的响应头 
         */
        void addIntHeader(const std::string& h_key, const int& h_value);

        /* 该方法是设置只有一个值且值的类型为long类型的响应头,例如expies响应头,表示过期时间 
         */
        void addDateHeader(const std::string& h_key, const long& h_value);

        /* 该方法是设置只有一个值的响应头,参数name表示响应头名称,参数value表示响应头的值 
         */
        void setHeader(const std::string& h_key, const std::string& h_value);

        /* 该方法是设置只有一个值且值的类型为int类型的响应头,例如Content-Length响应头，
         * 该响应头是代表响应内容有多少字节数 
         */
        void setIntHeader(const std::string& h_key, const int& h_value);

        /* 该方法是设置只有一个值且值的类型为long类型的响应头,例如expies响应头,表示过期时间 
         */
        void setDateHeader(const std::string& h_key, const long& h_value);
//-----------------------------------------------------------------------------------

public:
        std::string getHeader();
};

#endif  // __WHPS_RESPONSE_H__

#ifndef __WHPS_RESPONSE_WRAPPER_H__
#define __WHPS_RESPONSE_WRAPPER_H__

#include <map>
#include <string>

#include "WhpsWriter.h"
#include "HttpWriterRegistser.h"

typedef std::map<std::string, std::string>  HttpHeader__;
typedef std::string                         HttpBody__;

#define HttpResponseHeader      HttpHeader__
#define HttpResponseBody        HttpBody__

class WHPSResponseWrapper
{
public:
        using cbFunc = HttpWriterRegistser::cbFunc;
public:
        WHPSResponseWrapper(cbFunc cb);
        virtual ~WHPSResponseWrapper();

        /* 多态性，返回基类的对象，供子类使用 */
        WHPSResponseWrapper* _getResponse();

protected:      /* 标准响应头函数*/
        /* 设置Content-Length字段值
         */
        void _setContentLength(const std::string& length);

        /* 设置Content-type字段值
         */
        void _setContentType(const std::string& type);

//-----------------------------------------------------------------------------------
protected:      /* 以下是添加自定义响应头和时间的函数 */
        /* 该方法是设置有多个值的响应头,参数name表示响应头名称,参数value表示响应头的值 
         */
        void _addHeader(const std::string& h_key, const std::string& h_value);

        /* 该方法是设置有多个值且值的类型为int类型的响应头 
         */
        void _addIntHeader(const std::string& h_key, const int& h_value);

        /* 该方法是设置只有一个值且值的类型为long类型的响应头,例如expies响应头,表示过期时间 
         */
        void _addDateHeader(const std::string& h_key, const long& h_value);

        /* 该方法是设置只有一个值的响应头,参数name表示响应头名称,参数value表示响应头的值 
         */
        void _setHeader(const std::string& h_key, const std::string& h_value);

        /* 该方法是设置只有一个值且值的类型为int类型的响应头,例如Content-Length响应头，
         * 该响应头是代表响应内容有多少字节数 
         */
        void _setIntHeader(const std::string& h_key, const int& h_value);

        /* 该方法是设置只有一个值且值的类型为long类型的响应头,例如expies响应头,表示过期时间 
         */
        void _setDateHeader(const std::string& h_key, const long& h_value);
//-----------------------------------------------------------------------------------

protected:
        /* 获取可以返回的http响应头全部信息 */
        std::string _getHeader();

        /* 获取http响应发送器 */
        WhpsWriter& _getWriter();
private:
        /* 初始化响应头的默认参数 */
        void initParams();

        HttpResponseHeader      _header;                    // 响应头(K-V格式)
        std::string             _version/* = "HTTP/1.1"*/;  // 协议版本(应与请求头版本一致)
        std::string             _st_code/* = "200"*/;       // http状态码
        std::string             _status/* = "OK"*/;         // http状态信息
        HttpResponseBody        _body;                      // 响应体

        WhpsWriter              _writer;                    // 发送器
};

#endif

#ifndef __WHPS_WRITER_H__
#define __WHPS_WRITER_H__

#include <string>
#include <functional>

/* http响应回写类
 * 作为HttpResponse的子对象，负责将响应信息，回写给客户端
 */
class WhpsWriter
{
        using cbFunc = std::function<void(const std::string&)>;
public:
        WhpsWriter(cbFunc cb);
        ~WhpsWriter();

public:
        void write(const std::string& msg);

private:
        cbFunc _cb_func;
};

#endif  // __WHPS_WRITER_H__

#ifndef __FACTORY_BASE_H__
#define __FACTORY_BASE_H__

/* 所有工厂类的基类
 * 提供最基础的工厂设施
 */
class FactoryBase
{
public:
        virtual ~FactoryBase()
        {

        }

protected:
        FactoryBase()
        {
                
        }
};

#endif  // __FACTORY_BASE_H__
#ifndef __HTTP_WHPS_FACTORY_H__
#define __HTTP_WHPS_FACTORY_H__

#include <memory>

#include "ImplSingleton.h"
#include "SingletonRegister.h"
#include "FactoryBase.h"
#include "HttpWhps.h"
#include "WHPSConfig.h"

#include <iostream>
using namespace std;

/* HttpWhps应用层子类实例化的工厂类（动态对象创建工厂）
 * 该类只会获取一个继承自HttpWhps的子类信息，并将其实例化
 * 返回基类HttpWhps的指针
 * （该文件内容应在编译时自动生成！）
 * 单例模式
 */
class HttpWhps;
class HttpWhpsFactory: public ImplSingleton<HttpWhpsFactory>, public FactoryBase
{
public:
        using CreateFunction = std::function<std::shared_ptr<HttpWhps>()>;
        using HttpPtrType = std::shared_ptr<HttpWhps>;
public:
        static HttpWhpsFactory* GetInstance()
        {
                if (!_http_whps_factory.get())
                {
                        _http_whps_factory = std::shared_ptr<HttpWhpsFactory>(new HttpWhpsFactory());
                }

                return _http_whps_factory.get();
        }
public:
        HttpWhpsFactory()
                : ImplSingleton<HttpWhpsFactory>()
                , FactoryBase()
        {

        }

        virtual ~HttpWhpsFactory()
        {

        }

public:
        /* 创建应用层对象
         * （1）获取所有继承自HttpWhps类的子类；
         * （2）所有子类中，只实例化最新的一个；
         */
        // HttpWhps* create()
        // {
        //         // 当前测试，先写死一个子类
        //         // std::shared_ptr<HelloWhps> ptr(new HelloWhps());

        //         string whpsName = GetWebSourceConfig().get("whps", "whps-name");    // 获取whps实例的名字
        //         // 以下添加从实例注册中心获取实例对象

        //         HttpWhps* ptr = new HelloWhps();
        //         return ptr;
        // }

public:
        HttpPtrType get(const std::string& type);
public:
        bool create(const std::string& type_name);

        HttpPtrType _create(const std::string & type_name);
 
        // 解析类型名称（转换为 A::B::C 的形式）
        static std::string readTypeName(const char* name);
 
        bool regist(const char * name, CreateFunction func);

private:
        static std::shared_ptr<HttpWhpsFactory> _http_whps_factory;

        Map<std::string, CreateFunction> _create_function_map;     // 对象名和创建函数的对应关系
        Map<std::string, HttpPtrType> _map_ptr;                    // 对象名和指针句柄的对应关系
};

GET_SINGLETON_OBJECT_PTR(HttpWhpsFactory)

#endif  // __HTTP_WHPS_FACTORY_H__/*
 * HttpWriterRegistser.h
 *
 *  Created on: Aug 2, 2019
 *      Author: wenhan
 */

#ifndef __HTTP_WRITER_REGISTSER_H__
#define __HTTP_WRITER_REGISTSER_H__

#include "ImplRegisterBase.h"

// template<class T>
// class HttpWriterRegistser: public ImplRegisterBase<T>
class HttpWriterRegistser: public ImplRegisterBase
{
public:
        using cbFunc = typename ImplRegisterBase::cbFunc;
public:
        HttpWriterRegistser()
                : ImplRegisterBase()
        {

        }
        virtual ~HttpWriterRegistser()
        {

        }

public:
        /* 注册http回写接口 */
        virtual void registObj(cbFunc cb)
        {
                _cb_func = cb;
        }

        virtual cbFunc getRegistObj()
        {
                return _cb_func;
        }

private:
        cbFunc _cb_func;
};

#endif  //__HTTP_WRITER_REGISTSER_H__
/*
 * ImplRegisterBase.h
 *
 *  Created on: Aug 2, 2019
 *      Author: wenhan
 */

#ifndef __IMPL_REGISTER_BASE_H__
#define __IMPL_REGISTER_BASE_H__

#include <functional>
#include <string>

/* 功能注册器接口 */
// template<class T>
class ImplRegisterBase
{
public:
        using cbFunc = std::function<void(const std::string&)>;
public:
        virtual ~ImplRegisterBase()
        {

        }

protected:
        ImplRegisterBase()
        {

        }

protected:      // 接口集
        /* 注册接口入口 */
        virtual void registObj(cbFunc cb) = 0;

        /* 获取注册的接口 */
        virtual cbFunc getRegistObj() = 0;
};

#endif  // __IMPL_REGISTER_BASE_H__

#ifndef __WHPS_OBJ_REGISTER_BASE_H__
#define __WHPS_OBJ_REGISTER_BASE_H__

#include "ImplRegisterBase.h"

/* whps子类注册函数
 * 编译期注入子类类型，动态创建子类对象
 */
class WhpsObjRegisterBase: public ImplRegisterBase
{
public:
        using cbFunc = ImplRegisterBase::cbFunc;
public:
        WhpsObjRegisterBase();

        virtual ~WhpsObjRegisterBase();

        virtual void registObj(cbFunc cb);

        virtual cbFunc getRegistObj();
};

#endif  // __WHPS_OBJ_REGISTER_BASE_H__
#include <stdlib.h>
#include <sstream>
#include <iomanip>

#include "util.h"
#include "WHPSConfig.h"

using namespace std;

void exitService(int status)
{
        exit(status);
}

void delayMs(const unsigned int& ms)
{
        const timespec ts = {0, ms};
        nanosleep(&ts, NULL);        // 线程级别的睡眠（毫秒级）
}

string getHexString(unsigned char* s, const int& len)
{
        std::ostringstream out;
        out << std::hex << std::setw(2) << std::setfill('0');

        for (int i = 0; i < len; i++) {
                out << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(s[i]) << " ";
        }

        return out.str();
}

void initConfig()
{
        if (!GetWebSourceConfig().readConfig())
        {
                cout << "Config file load failed..." << endl;
                exit(-1);
        }

        GetWebSourceConfig().print();
}
#include "WHPSConnSocket.h"

#include <iostream>
using namespace std;

#if 0
WHPSConnSocket::WHPSConnSocket()
{

}
#endif

WHPSConnSocket::WHPSConnSocket(int fd)
{
        this->set(fd);
}

WHPSConnSocket::~WHPSConnSocket()
{
        this->close();
}

bool WHPSConnSocket::isValid()
{
       return this->__isValid(); 
}

const int& WHPSConnSocket::get() const
{
        return this->__get();
}

void WHPSConnSocket::set(int fd)
{
        this->__set(fd);
}

int WHPSConnSocket::setNonblock()
{
        return this->__setNonblock();
}

int WHPSConnSocket::setOption()
{
        return this->__setSocketOpt();
}

int WHPSConnSocket::close()
{
        if (this->isValid())
        {
                return this->__close();
        }

        return 0;
}

#include "WHPSEpollEventLoop.h"

WHPSEpollEventLoop::WHPSEpollEventLoop(int maxevents /*= 1024*/, int timeout /*= 100*/)
        : _poller(maxevents, timeout)
        , _event_queue()
        , _is_stop(false)
{

}

WHPSEpollEventLoop::~WHPSEpollEventLoop()
{
        _is_stop = true;
}

void WHPSEpollEventLoop::stop()
{
        _poller.setTimeout(0);  // 立即返回
        _is_stop = true;
}

void WHPSEpollEventLoop::addEvent(event_chn* p_event)
{
        _poller.addEvent(p_event);
}

void WHPSEpollEventLoop::delEvent(event_chn* p_event)
{
        _poller.delEvent(p_event);
}

void WHPSEpollEventLoop::updateEvent(event_chn* p_event)
{
        _poller.updateEvent(p_event);
}

Task<WHPSEpollEventLoop::task_t>& WHPSEpollEventLoop::getTask()
{
        return _task;
}

void WHPSEpollEventLoop::addTask(task_t func_cb)
{
        _task.addTask(func_cb);
}

#include <iostream>
#include <thread>
#include <mutex>
using namespace std;
std::mutex mutex__;
void WHPSEpollEventLoop::loop()
{
        while (!_is_stop)
        {
                _poller.poll(_event_queue);         // 获取当前所有的事件

                /* 当前是线程池所有线程公用一个事件队列，不加锁会崩溃
                 * 此处需要修改成每个线程单独一个事件队列即可
                 */
                // mutex__.lock();
                for (event_chn* chn : _event_queue)     // 遍历事件队列
                {
                        if (chn)
                        {
                                chn->exCallback();
                        }
                }

                _event_queue.clear();   // 执行结束后清空队列
                // mutex__.unlock();
        }
}

#include <unistd.h>
void WHPSEpollEventLoop::loopOne()
{
        _poller.poll(_event_queue);         // 获取当前所有的事件

        /* 当前是线程池所有线程，每个线程单独一个事件队列
         */
        for (event_chn* chn : _event_queue)     // 遍历事件队列
        {
                if (chn)
                {
                        // sleep(10);      // 当A线程执行到此时，B线程执行了WHPSTcpSession的析构函数(客户端断开)，valgrind会报错(必现)
                        chn->exCallback();
                }
        }

        _event_queue.clear();   // 执行结束后清空队列
}
#include <sys/epoll.h>

#include "WHPSEventHandler.h"

WHPSEventHandler::WHPSEventHandler()
{

}

WHPSEventHandler::~WHPSEventHandler()
{
        std::lock_guard<std::mutex> lock(_mutex);
        _cb_read = nullptr;
        _cb_write = nullptr;
        _cb_error = nullptr;
        _cb_close = nullptr;
}

void WHPSEventHandler::setFd(const int& fd)
{
        __setFd(fd);
}

const int& WHPSEventHandler::getFd()
{
        return __getFd();
}

void WHPSEventHandler::setEvents(events_t events)
{
        __setEvents(events);
}

const events_t& WHPSEventHandler::getEvents() const
{
        return __getEvents();
}

void WHPSEventHandler::setReadCallback(CbFunc cb)
{
        this->setCallback(_cb_read, cb);
}

void WHPSEventHandler::setWriteCallback(CbFunc cb)
{
        this->setCallback(_cb_write, cb);
}

void WHPSEventHandler::setErrorCallback(CbFunc cb)
{
        this->setCallback(_cb_error, cb);
}

void WHPSEventHandler::setCloseCallback(CbFunc cb)
{
        this->setCallback(_cb_close, cb);
}

void WHPSEventHandler::setCallback(CbFunc& cb_s, CbFunc cb_d)
{
        this->__setCallback(cb_s, cb_d);
}

void WHPSEventHandler::exCallback()
{
        this->__exCallback();
}

void __stdcall WHPSEventHandler::__setCallback(__callback_t& __cb_s, __callback_t __cb_d)
{
        __cb_s = __cb_d;
}

void WHPSEventHandler::onCall(CbFunc cb)
{
        std::lock_guard<std::mutex> lock(_mutex);
        if (cb)
        {
                cb();
        }
}

#include <iostream>
/* 执行回调函数接口 */
void __stdcall WHPSEventHandler::__exCallback()
{
        events_t events = this->getEvents();
        /* 在使用2.6.17之后版本内核的服务器系统中，对端连接断开触发的epoll事件会包含EPOLLIN | EPOLLRDHUP，即0x2001。
         */
        if (events & EPOLLRDHUP)         // 对端异常关闭事件
        {
                _cb_close();
        }
        else if (events & (EPOLLIN | EPOLLPRI))  //读事件，对端有数据或者正常关闭
        {
                _cb_read();
        }
        else if (events & EPOLLOUT)  //写事件
        {
                _cb_write();
        }
        else    // 目前连接错误还没有测试过(未出现)
        {
                _cb_error();  //连接错误
        }
}

#include <string.h>

#include "WHPSPoller.h"

WHPSPoller::WHPSPoller(int maxevents, int timeout)
        : Poller(maxevents, timeout)
{

}
       
WHPSPoller::~WHPSPoller()
{

}

void WHPSPoller::addEvent(event_chn* p_event)
{
        this->eventOperation(ADD, p_event);
}

void WHPSPoller::delEvent(event_chn* p_event)
{
        this->eventOperation(DEL, p_event);
}

void WHPSPoller::updateEvent(event_chn* p_event)
{
        this->eventOperation(UPDATE, p_event);
}

#include <iostream>
using namespace std;
void WHPSPoller::setTimeout(int timeout)
{
        this->__setTimeout(timeout);
}

void WHPSPoller::eventOperation(OpsType type, event_chn* p_event)
{
        int fd = p_event->getFd();
        SEplEvent evt;
        memset(&evt, 0, sizeof(evt));
        evt.events = p_event->getEvents();
        evt.data.fd = fd;
        evt.data.ptr = p_event;
        switch (type)
        {
        case ADD:
        {
                this->addToEventList(fd, p_event);
                this->__addEvent(fd, evt);
                break;
        }
        case DEL:
        {
                this->delFromEventList(fd);
                this->__delEvent(fd, evt);
                break;
        }
        case UPDATE:
        {
                this->__updateEvent(fd, evt);
                break;
        }
        }
}

int WHPSPoller::epollWait()
{
        return this->__poll(_events);
}

int WHPSPoller::poll(Vector<event_chn*>& event_queue)
{

        int n_fds = this->epollWait();

        if (n_fds < 0)
        {
                cerr << "epoll wait error, err: " << strerror(errno) << endl;
                return -1;
        }

        this->onEvent(event_queue, n_fds);

        return 0;
}

#if 0
        typedef union epoll_data
        {
                void *ptr;
                int fd;
                uint32_t u32;
                uint64_t u64;
        } epoll_data_t;

        struct epoll_event
        {
                uint32_t events;      /* Epoll events */
                epoll_data_t data;    /* User data variable */
        } __EPOLL_PACKED;
#endif
void WHPSPoller::onEvent(Vector<event_chn*>& event_queue, const int& n_fds)
{
        for (int i = 0; i < n_fds; i++)
        {
                int events = _events[i].events;                         // 获取被触发的事件类型
                event_chn* p_event = (event_chn*)_events[i].data.ptr;   // 获取被触发的事件指针
                const int& fd = p_event->getFd();                       // 获取事件对应的句柄
                Map<int, event_chn*>::iterator it = _event_list.find(fd);

                if (it != _event_list.end())    // 在事件表中找到了对应的句柄
                {
                        p_event->setEvents(events);     // 设置句柄本次触发的事件类型
                        event_queue.push_back(p_event); // 向队列添加事件
                }
        }
}



void WHPSPoller::addToEventList(int fd, event_chn* p_event)
{
        _event_list.insert(fd, p_event);
}

void WHPSPoller::delFromEventList(int fd)
{
        _event_list.erase(fd);
}

/*
void WHPSPoller::updateEventList(int fd)
{
        // nothing to do
}
*/

#include <iostream>
#include "WHPSSocket.h"
#include "WHPSConfig.h"

using namespace std;

// int g_port = 3000;              // 可做成配置项

WHPSSocket::WHPSSocket(int mode)
        : _mode(mode)
        , _tcp_port(atoi(GetWebSourceConfig().get("Server", "tcpPort").c_str()))
{
        
}

WHPSSocket::~WHPSSocket()
{

}

const int& WHPSSocket::get() const
{
        return this->__get();
}

int WHPSSocket::init()
{
        if (_mode == SERVER_MODE)
        {
                return this->initServerMode();
        }
        else if(_mode == CLIENT_CONN_MODE)
        {
                return this->initClientConnMode();
        }

        return -1;      // 未知服务类型
}

int WHPSSocket::initServerMode()
{
        if (this->socket() < 0)
        {
                cout << "create socket failed..." << endl;
                return -1;
        }

        if (this->setNonblock())
        {
                cout << "setNonblock failed..." << endl;
                return -1;
        }

        if (this->setReuseAddr())
        {
                cout << "setReuseAddr failed..." << endl;
                return -1;
        }

        if (this->bind(_tcp_port))
        {
                cout << "bind failed..." << endl;
                return -1;
        }

        if (this->listen())
        {
                cout << "listen failed..." << endl;
                return -1;
        }

        return 0;
}

int WHPSSocket::initClientConnMode()
{
        return 0;
}

void WHPSSocket::set(int fd)
{
        this->__set(fd);
}

/* 设置socket属性 */
int WHPSSocket::setSocketOpt()
{
        return this->__setSocketOpt();
}

/* 设置非阻塞socket */
int WHPSSocket::setNonblock()
{
        return this->__setNonblock();
}

int WHPSSocket::socket()
{
        return this->__socket();
}

int WHPSSocket::bind(const int& port, const char* ip)
{
        return this->__bind(port, ip);
}

int WHPSSocket::listen()
{
        return this->__listen();
}

int WHPSSocket::accept()
{
        return this->__accept();
}

int WHPSSocket::accept(struct sockaddr_in& c_addr)
{
        return this->__accept(c_addr);
}

#if 0
struct sockaddr_in WHPSSocket::accpet()
{
        return this->__accept();
}
#endif

int WHPSSocket::setReuseAddr()
{
        return this->__setReuseAddr();
}

int WHPSSocket::close()
{
        return this->__close();
}

#include <iostream>
using namespace std;

#include "WHPSTcpServer.h"
#include "WHPSConnSocket.h"
#include "WHPSConfig.h"

// static int g_nthreads = 1;     // 可做成配置(至少是1)

std::shared_ptr<WHPSTcpServer> WHPSTcpServer::_tcp_server;
// WHPSTcpServer::GC WHPSTcpServer::_gc;

WHPSTcpServer::WHPSTcpServer()
        : ImplSingleton<WHPSTcpServer>()
        , _loop()
        , _thread_pool(atoi(GetWebSourceConfig().get("Server", "ioThreads").c_str()), _loop)
        , _tcp_socket(SERVER_MODE)
{
        
}

WHPSTcpServer::~WHPSTcpServer()
{
        cout << "WHPSTcpServer::~WHPSTcpServer" << endl;
}

WHPSTcpServer* WHPSTcpServer::GetInstance()
{
        // if (!_tcp_server.get())
        if (!_tcp_server)
        {
                _tcp_server = std::shared_ptr<WHPSTcpServer>(new WHPSTcpServer());
        }

        return _tcp_server.get();
}

bool WHPSTcpServer::isValid()
{
        return _tcp_socket.isValid();
}

WHPSTcpSocket& WHPSTcpServer::getSocket()
{
        return _tcp_socket;
}


WHPSEpollEventLoop& WHPSTcpServer::loop()
{
        return _loop;
}

bool WHPSTcpServer::start()
{
        if (_tcp_socket.init() < 0)     // 启动失败
        {
                cout << "tcp socket init failed..." << endl;

                return false;
        }

        if (!this->isValid())
        {
                cout << "socket is invalid..." << endl;

                return false;
        }

        _thread_pool.start();

        _event_chn.setFd(_tcp_socket.get());
        _event_chn.setEvents(EPOLLIN | EPOLLET);        // 设置接收连接事件，epoll模式为边缘触发

        _event_chn.setReadCallback(std::bind(&WHPSTcpServer::onNewConnection, this, 0));
        _event_chn.setErrorCallback(std::bind(&WHPSTcpServer::onNewConnection, this, 1));

        _loop.addEvent(&_event_chn);

        return true;
}

#include <unistd.h>
void WHPSTcpServer::startLoop()
{
        _loop.loop();
}

void WHPSTcpServer::onNewConnection(error_code error)
{
        if (error)      // 客户端连接错误
        {
                cout << "error_code: " << error << endl;

                return;
        }

        this->onNewSession();
}

#include <unistd.h>
void WHPSTcpServer::onNewSession()
{
        //循环调用accept，获取所有的建立好连接的客户端fd
        struct sockaddr_in c_addr;
        int fd = -1;

        while ((fd = _tcp_socket.Accept(c_addr)) > 0)         // 高并发时，可能返回多个连接的事件，因此循环处理
        {
                sp_TcpSession sp_tcp_session(new WHPSTcpSession(_thread_pool.getOneLoop(), fd, c_addr));   // 实例化客户端对象

                // 设置客户端相关参数、回调功能
                //sp_tcp_session->setCleanUpCallback(std::bind(&WHPSTcpServer::onCleanUpResource, this, sp_tcp_session));
                TcpSessionCB cb = std::bind(&WHPSTcpServer::onCleanUpResource, this, std::placeholders::_1);
                _tcp_sess_list[fd] = sp_tcp_session;
                sp_tcp_session->setCleanUpCallback(cb);         // 该任务属于线程任务，不属于epoll事件，因此需要设置线程回调函数才能被执行

                _cb_connect(sp_tcp_session);

                // 将客户端回调任务加入到WHPSEventLoop中
                sp_tcp_session->addToEventLoop();
        }
}

void WHPSTcpServer::onCleanUpResource(const sp_TcpSession& sp_tcp_session)
{
        _tcp_sess_list.erase(sp_tcp_session->getConn().get());
        cout << "WHPSTcpServer::onCleanUpResource-----size: " << _tcp_sess_list.size() << endl;

        if (!_tcp_sess_list.size())     // 主要是释放map的内存，可能没用（后面换个方法）
        {
                cout << "WHPSTcpServer::onCleanUpResource-----list empty: " << _tcp_sess_list.size() << endl;
                _tcp_sess_list.clear();
        }
}

void WHPSTcpServer::setNewConnCallback(cbFunc cb)
{
        _cb_connect = cb;
}

void WHPSTcpServer::setNewCloseCallback(cbFunc cb)
{
        _cb_close = cb;
}
#include <iostream>
#include <unistd.h>
using namespace std;

#include "WHPSTcpSession.h"
#include "util.h"

WHPSTcpSession::WHPSTcpSession(WHPSEpollEventLoop& loop, const int& fd, struct sockaddr_in& c_addr)
        : std::enable_shared_from_this<WHPSTcpSession>()
        , _c_addr(c_addr)
        , _loop(loop)
        , _conn_sock(fd)
        , _base_events(EPOLLIN | EPOLLPRI)
        , _is_connect(true)
        , _is_processing(false)
        , _is_wait(false)
{
        _conn_sock.setOption();
        this->getEndpointInfo();
        /* 每个客户端的socket要设置成非阻塞，否则在read或write会使线程阻塞，无法实现异步和线程复用 */
        _conn_sock.setNonblock();

        _event_chn.setFd(_conn_sock.get());
        // _event_chn.setEvents(EPOLLIN | EPOLLPRI | EPOLLOUT); // 不能设置EPOLLOUT，否则客户端连接，会频繁调用onNewWrite()
        _event_chn.setEvents(_base_events);        // 设置接收连接事件，epoll模式为边缘触发

        _event_chn.setReadCallback(std::bind(&WHPSTcpSession::onNewRead, this, 0)); // 注册数据接收回调函数
        _event_chn.setWriteCallback(std::bind(&WHPSTcpSession::onNewWrite, this, 0)); // 注册数据发送回调函数
        _event_chn.setCloseCallback(std::bind(&WHPSTcpSession::onNewClose, this, 0)); // 注册连接关闭回调函数
        _event_chn.setErrorCallback(std::bind(&WHPSTcpSession::onNewError, this, 0)); // 注册异常错误回调函数

        // 还需要注册发送数据和超时回调
}

WHPSTcpSession::~WHPSTcpSession()
{
        this->release();
        _conn_sock.close();
}

void WHPSTcpSession::getEndpointInfo()
{
        struct sockaddr_in sa;
        socklen_t len = sizeof(sa);
        if (!getpeername(_conn_sock.get(), (struct sockaddr *) &sa, &len))
        {
                _client_ip = string(inet_ntoa(sa.sin_addr));
                _client_port = ntohs(sa.sin_port);
                _net_info = _client_ip + ":" + to_string(_client_port);
        }

	cout << "a client has been connected: " << _net_info << endl;
}

const std::string& WHPSTcpSession::getIp() const
{
        return _client_ip;
}

const int& WHPSTcpSession::getPort() const
{
        return _client_port;
}

const std::string& WHPSTcpSession::getNetInfo() const
{
        return _net_info;
}

bool WHPSTcpSession::isValid()
{
        return _conn_sock.isValid();
}

const int& WHPSTcpSession::get() const
{
        return _conn_sock.get();
}

WHPSConnSocket& WHPSTcpSession::getConn()
{
        return _conn_sock;
}

void WHPSTcpSession::close()
{
        _is_wait = true;
        _is_processing = false;
        _buffer_in.clear();
        _buffer_out.clear();
        this->onNewClose(0);
}

void WHPSTcpSession::addToEventLoop()
{
        _loop.addEvent(&_event_chn);    // 所有请求都由主线程处理(后续要修改成多线程)
}

void WHPSTcpSession::delFromEventLoop()
{
        _event_chn.setEvents(_base_events);
        _loop.updateEvent(&_event_chn);
        _loop.delEvent(&_event_chn);
}

void WHPSTcpSession::setCleanUpCallback(TcpSessionCB& cb)
{
        _cb_cleanup = cb;
}

void WHPSTcpSession::onCall(httpCB cb)
{
#if 0
        std::lock_guard<std::mutex> lock(_mutex);

        if (!_is_connect)
        {
                return;
        }
#endif

        if (!cb)
        {
                return;
        }

        cb();
}

void WHPSTcpSession::release()
{
                {
                        std::lock_guard<std::mutex> lock(_mutex);
                        if (!_is_connect)
                        {
                                return;
                        }

                        this->delFromEventLoop();
                          // _loop.addTask(std::bind(_cb_cleanup, shared_from_this())); // 执行清理回调函数
                        _is_connect = false;
                        _is_wait = true;
                        _is_processing = false;
                        _buffer_in.clear();
                        _buffer_out.clear();
                }

        try
        {
                _cb_cleanup(shared_from_this());
        }
        catch (exception& e)
        {
                // pass
                //cout << "WHPSTcpSession::release: " << e.what() << endl;
        }
}

void WHPSTcpSession::send(const std::string& msg)
{
        _buffer_out = msg;
        int res = this->sendTcpMessage(_buffer_out);    // 需要判别发送的结果，从而决定要不要关闭连接

        if (res > 0)    // 正确发送数据
        {
                events_t events = _event_chn.getEvents();

                if (_buffer_out.size())     // 还有数据未发送(可能是tcp缓冲区占满导致)
                {
                        events = events | EPOLLOUT;         // 设置写监听
                }
                else        // 数据发送完毕
                {
                        events = _base_events;      // 数据发送完毕，无需继续监听写操作
//                        _http_onSend(shared_from_this());
                        this->onCall(_http_onSend);

                        if (_is_wait)
                        {
                                this->onNewClose(0);
                        }
                }

                _event_chn.setEvents(events);
                _loop.updateEvent(&_event_chn);
        }
        else if (res == 0)    // 数据发送异常
        {
                onNewClose(-1); // 关闭连接
        }
        else
        {
                onNewError(-1); // 错误处理，释放资源
        }
}

int WHPSTcpSession::sendTcpMessage(std::string& buffer_out)
{
        /* 当前发送数据，是一个线程将_buffer_out中的所有数据全部发送
         * 后续是否需要改成每次只发送一比数据，之后的数据靠epoll事件触发？
         */
        int res = -1;

        long bytes_transferred = 0;
        while (true)
        {
                // int w_nbytes = write(_conn_sock.get(), buffer_out.c_str(), buffer_out.size());
                /* 写入数据可能产生 SIGPIPE 信号
                 * 对发送函数设置 MSG_NOSIGNAL，可忽略此信号，不至于进程退出
                 */
                int w_nbytes = ::send(_conn_sock.get(), buffer_out.c_str(), buffer_out.size(), MSG_NOSIGNAL);
                bytes_transferred += w_nbytes;

                if (w_nbytes > 0)   // 该笔数据已发送
                {
                        buffer_out.erase(0, w_nbytes); // 清除缓冲区中已发送的数据(不适用于重发的情况)

                        if (_buffer_out.size() == 0)
                        {
                                res = bytes_transferred;
                                break;
                        }

                }
                else if (w_nbytes == 0)
                {
                        if (errno == EAGAIN)    // 数据正确的发送完成，再次调用的返回结果
                        {
                                res = bytes_transferred;
                        }

                        break;
                }
                else    // 写数据异常
                {
                        if (errno == EAGAIN)    // tcp发送缓冲区满了，下次继续发送
                        {
                                /* 这里统一返回1！
                                 *  若返回bytes_transferred，当写一次出错时，同时errno是EAGAIN，不应关闭
                                 *  但实际的bytes_transferred结果为-1，会导致异常关闭。
                                 */
                                res = 1;
                        }
                        else if (errno == EPIPE) // 客户端已经close，并发了RST，继续wirte会报EPIPE，返回0，表示close
                        {
				// pass
                        }
                        else if (errno == EINTR) // 中断，write()会返回-1，同时置errno为EINTR
                        {
				// pass
                        }
                        else
                        {
                                cout << "unknow errno type..." << endl;
                        }

                        break;
                }
        }

        return res;
}

#include <thread>
void WHPSTcpSession::onNewRead(error_code error)
{
        int res = this->readTcpMessage(_buffer_in);

        if (res > 0)
        {
                // 进行业务层的数据数据(tcp数据处理)
                // 异步回调方式，epoll线程跟业务线程分离
//                _http_onMessage(shared_from_this());
                this->onCall(_http_onMessage);

#if 0           // 测试socket关闭后，再发送数据的错误处理
                TestSend(this);
                // 测试发送接口修改成通过向任务队列抛任务的方式，由不同的线程异步执行
#endif
        }
        else if (res == 0)
        {
                onNewClose(-1); // 关闭连接
        }
        else
        {
                onNewError(-1); // 错误处理，释放资源
        }
}

int WHPSTcpSession::readTcpMessage(std::string& buffer_in)
{
        int res = -1;
        int bytes_transferred = 0;

        while (true)
        {
                char buffer[1024];
                // int r_nbyte = read(_conn_sock.get(), buffer, 1);
                /* 参考nginx实现方式
                 */
                // int r_nbyte = recvfrom(_conn_sock.get(), buffer, 1024, 0, NULL, NULL);
                int r_nbyte = recv(_conn_sock.get(), buffer, 1024, 0);

                if (r_nbyte > 0)
                {
                        _buffer_in.append(buffer, r_nbyte);     // 每次追加写入数据
                        bytes_transferred += r_nbyte;
                }
                else if (r_nbyte == 0)    // 客户端关闭socket，FIN包
                {
                        res = 0;
                        break;
                }
                else    // 读数据异常(-1)
                {
                        // 异步时，当缓冲区无数据时，read会返回-1,即：读完了
                        /* 在非阻塞模式下调用了阻塞操作，在该操作没有完成就返回这个错误，
                         * 这个错误不会破坏socket的同步，下次循环接着recv就可以。
                         */
                        if (errno == EAGAIN)
                        {
                                // pass
                                // res = bytes_transferred;
                                res =
                                                                (bytes_transferred
                                                                                                == 0) ?
                                                                                                1 :
                                                                                                bytes_transferred;
                        }
                        else if (errno == EINTR) // 中断，read()会返回-1，同时置errno为EINTR
                        {

                        }

#if 0   // send msg test(测试发送的异常情况)
                        TestSend(this);
#endif
                        break;
                }
        }

        return res;
}

void WHPSTcpSession::onNewWrite(error_code error)
{
        int res = this->sendTcpMessage(_buffer_out);    // 需要判别发送的结果，从而决定要不要关闭连接

        if (res > 0)    // 正确发送数据
        {
                events_t events = _event_chn.getEvents();

                if (_buffer_out.size())     // 还有数据未发送(可能是tcp缓冲区占满导致)
                {
                        events = events | EPOLLOUT;         // 设置写监听
                }
                else        // 数据发送完毕
                {
                        events = _base_events;      // 数据发送完毕，无需继续监听写操作
//                        _http_onSend(shared_from_this());
                        this->onCall(_http_onSend);
                        if (_is_wait)
                        {
                                this->onNewClose(0);
                        }
                }

                _event_chn.setEvents(events);
                _loop.updateEvent(&_event_chn);
        }
        else if (res == 0)    // 数据发送异常
        {
                onNewClose(-1); // 关闭连接
        }
        else
        {
                onNewError(-1); // 错误处理，释放资源
        }
}

void WHPSTcpSession::onNewClose(error_code error)
{
        /* 防止陷入死循环
         * 正常执行完_cb_cleanup,清除对应的智能指针占用,可以使其引用计数降为0,从而正确退出session.
         * 而因为addTask传递_cb_cleanup,所携带shared_from_this(),会使指向当前对象的shared_ptr引用计数加1,
         * 因此,再次引用时,无需执行此函数,直接返回,使引用计数降为0即可.
         */
        if (!_is_connect)
        {
                return;
        }
        /* 关闭数据需要做两件事情
         *      （1）处理剩余数据(接收_buffer_in/发送_buffer_out)————(暂不考虑，后续扩展)
         *      （2）关闭socket
         *      （3）通知主socket对象和EventLoop对象删除该句柄资源
         */
// if (_buffer_in.size() || _buffer_out.size() || _is_processing)
        if (_buffer_in.size() || _buffer_out.size())
        {
                if (_buffer_in.size())
                {
//                        _http_onMessage(shared_from_this());
                        this->onCall(_http_onMessage);
                }
        }
        else
        {
                if (_is_wait)   // 如果服务端主动关闭，需要有延迟来保证对端接收数据完毕
                {
                        delayMs(0);
                }

                this->onCall(_http_onClose);
                this->release();
        }
}

void WHPSTcpSession::onNewError(error_code error)
{
        cout << "WHPSTcpSession::onNewError: " << this->getNetInfo() << endl;
        if (!_is_connect)
        {
                return;
        }
        /* 关闭数据需要做两件事情
         *      （1）关闭socket
         *      （2）通知主socket对象和EventLoop对象删除该句柄资源
         */
        this->onCall(_http_onError);
        this->release();
}

void WHPSTcpSession::setHttpMessageCallback(httpCB cb)
{
        _http_onMessage = cb;
}

void WHPSTcpSession::setHttpSendCallback(httpCB cb)
{
        _http_onSend = cb;
}

void WHPSTcpSession::setHttpCloseCallback(httpCB cb)
{
        _http_onClose = cb;
}

void WHPSTcpSession::setHttpErrorCallback(httpCB cb)
{
        _http_onError = cb;
}

void WHPSTcpSession::setProcessingFlag(bool is_processing)
{
        _is_processing = is_processing;
}

const bool& WHPSTcpSession::getProcessingFlag() const
{
        return _is_processing;
}
#include "WHPSTcpSocket.h"

WHPSTcpSocket::WHPSTcpSocket(int mode)
        : WHPSSocket(mode)
{

}

WHPSTcpSocket::~WHPSTcpSocket()
{
        
}

bool WHPSTcpSocket::isValid()
{
        return this->__isValid();
}

int WHPSTcpSocket::Accept(struct sockaddr_in& c_addr)
{
        return this->accept(c_addr);
}
#include "WHPSThread.h"

#include <iostream>
using namespace std;
WHPSThread::WHPSThread(Task<task_t>& task)
        : _thrd(_loop.getTask())
        , _is_stop(false)
{
        
}

WHPSThread::~WHPSThread()
{
        this->stop();
        _thrd.join();
}

void WHPSThread::start()
{
        task_func_t callback = std::bind(&WHPSThread::workFunc, this);
        _thrd.start(callback);
}

void WHPSThread::stop()
{
        _is_stop = true;
        _loop.stop();
}

WHPSEpollEventLoop& WHPSThread::getLoop()
{
        return _loop;
}

void WHPSThread::workFunc()
{
        while (!_is_stop)
        {
                /* 调用执行一次epoll任务的接口，因为线程还要处理Task queue中的内容 */
                _loop.loopOne();

                /* 处理Task queue中的内容，每次只取一个 */
                this->excuteTask();
        }
}

void WHPSThread::excuteTask()
{
        _thrd.excuteTask();
}

#include <iostream>

#include "WHPSThreadPool.h"

using namespace std;

WHPSThreadPool::WHPSThreadPool(int size, WHPSEpollEventLoop& main_loop)
        : _main_loop(main_loop)
        , _index(0)
        , _size(size)
{
        this->createThreads();

        if (_size > 100)
        {
                cout << "too many threads, exit..." << endl;
                exit(-1);
        }
}

WHPSThreadPool::WHPSThreadPool(int size, WHPSEpollEventLoop& main_loop, task_func_t callback)
        : _main_loop(main_loop)
        , _index(0)
        , _size(size)
        , _callback(callback)
{
        this->createThreads();

        if (_size > 100)
        {
                cout << "too many threads, exit..." << endl;
                exit(-1);
        }
}

WHPSThreadPool::~WHPSThreadPool()
{
        cout << "-------WHPSThreadPool::stop...." << endl;
        this->stop();
}

WHPSEpollEventLoop& WHPSThreadPool::getOneLoop()
{
        if (_size)      // 多线程
        {
                WHPSEpollEventLoop& loop = _v_th[_index]->getLoop();
                _index = (_index+1) % _size;
                cout << "------index: " << _index << endl;
                return loop;
        }
        else            // 单线程
        {
                return _main_loop;
        }
}

void WHPSThreadPool::start()
{
        for (int i = 0; i < _size; i++)
        {
                _v_th[i]->start();
        }
}

void WHPSThreadPool::createThreads()
{
        for (int i = 0; i < _size; i++)
        {
                WHPSThread* th = new WHPSThread(_task);
                _v_th.push_back(th);
        }
}

void WHPSThreadPool::stop()
{
        for (int i = 0; i < _size; i++)
        {
                // __v_th[i]->stop();
                delete _v_th[i];
        }
}
#include <iostream>
#include <string.h>
#include <sstream>      // for std::istringstream
#include <iterator>     // for std::istream_iterator

#include "WHPSImplMacroBase.h"
#include "WHPSHttpParser.h"
#include "util.h"

using namespace std;

/* 针对http请求行第一行，获取：
 *      请求方法、url和http版本信息
 */
static WHPSHttpParser::SpVector GetUrl(const string& sstr)
{
        stringstream iss(sstr);
        WHPSHttpParser::SpVector req_line;
        std::copy(istream_iterator<string>(iss), istream_iterator<string>(), back_inserter(req_line));

        return req_line;
}

static void GetKvSplit(HttpRequestContext& request, const string& sstr, const string& sep)
{
        if (sstr.empty())
        {
                return;
        }

        String s__(sstr);
        WHPSHttpParser::SpVector spv = s__.splitOnce(":");

        if (spv.size() == 2)         // 最好加上，双层判断保险
        {
                // header[spv[0]] = spv[1];
                request.setHeader(spv[0], spv[1]);
        }
}

/* 获取http请求体
 *      当前是按照文本保存，一般是json或text
 *      但若要支持文件上传等功能，可能需要做二进制数据的缓存（后续扩展）
 */
static bool GetContactContent(HttpRequestContext& request, WHPSHttpParser::SpVector& vrow_seq, const char* crlf)
{
        if (vrow_seq.empty())
        {
                return false;
        }

#if 0
        for (string s: vrow_seq)
        {
                body += (s+crlf);
        }
#else
        /* 标准http的body里面没有"\r\n"的符号，只有结尾有，
         * body的每一行应该是 '\n' 结尾。
         * 而vrow_seq序列在处理请求行的时候，已经将读取完的数据在序列中清除，
         * 因此，获取body时，不需要再进行拼接了，序列中下标为0的元素，就是body。
         */
        // body = vrow_seq[0];
        request.setBody(vrow_seq[0]);
#endif

        return true;
}

// 提取请求行中，第一行Url的内容
Impl_GET_CONTENT(Url, WHPSHttpParser::SpVector)

// 根据":"拆分成header的key和value
Impl_GET_KV_SPLIT(HttpRequestContext, ":")

Impl_GET_CONTACT(HttpRequestContext, WHPSHttpParser::SpVector, "\r\n")

WHPSHttpParser::WHPSHttpParser()
        : _crlf_old("\n")
        , _crlf("\r\n")
{

}

WHPSHttpParser::~WHPSHttpParser()
{

}

#include "WHPSLog.h"
void WHPSHttpParser::parseHttpRequest(std::string& raw_msg, HttpRequestContext& context)
{
#if 0   // 用于调试http输出的原始字符
        for (int i = 0; i < raw_msg.size(); i++)
        {
                printf("(%d, %c)", raw_msg[i], raw_msg[i]);
        }
        cout << endl;
#endif

        // 当前没有做包完整性校验，测试阶段默认一次请求一个完整的包
        SpVector vrow_seq = String(raw_msg).split(_crlf);
        this->parseSequence(vrow_seq, context);
}

/*
        struct HttpRequestContext
        {
                std::string                             _method;        // 请求方法
                std::string                             _url;           // 请求资源路径
                std::string                             _version;       // 协议版本
                std::map<std::string, std::string>      _header;        // 请求头(K-V格式)
                std::string                             _body;          // 请求体
        };
 */
void WHPSHttpParser::parseSequence(SpVector& vrow_seq, HttpRequestContext& context)
{
        if (!vrow_seq.size())   // 如果行序列为空，则直接返回
        {
                return;
        }

        if (!this->getFirstLine(vrow_seq, context))     // http请求第一行(特殊处理)
        {
                return;
        }

        this->getHeaderInfo(vrow_seq, context);         // http请求header信息
        
        if (!this->getBodyInfo(vrow_seq, context))      // http请求body信息
        {
                return;
        }
}

bool WHPSHttpParser::getFirstLine(SpVector& vrow_seq, HttpRequestContext& context)
{
        String first_line = String(vrow_seq[0]);
        SpVector req_line = GetContent(first_line.str());
        
        /* 格式检查：
         *      必须符合： METHOD URL VERSION 格式
         *      否则返回失败
         */
        if (req_line.size() != 3)
        {
                return false;
        }

        const string& method = req_line[0];
        context.setMethod(method);
        context.setUrl(String(req_line[1]).decode("UrlCode"));	// 防止中文
        context.setVersion(req_line[2]);
        context.setFlag(this->checkResourceType(context.getUrl()));  // 判断资源类型
        vrow_seq.erase(vrow_seq.begin());       // 处理之后，需要将第一行删除

        /* 当前仅可支持
         *      GET
         *      POST
         *      PUT
         *      DELETE
         * 四种方法 
        */
        if (method != "GET"
                && method != "POST"
                && method != "PUT"
                && method != "DELETE")
        {
                cout << "not support " << method << endl;

                return false;
        }

        return true;
}

bool WHPSHttpParser::checkResourceType(const std::string& url)
{
        /* （1）检测的关键是 url 中是否带有相应的关键字符（比如"?"、"&"、"="等字符）
         * （2）静态资源格式必须符合：
         *          http://192.168.12.250:3000/A/B/C/D/1.png
         *      对应的 url 应为：
         *          /A/B/C/D/1.png
         *      <注意>：url不能包含"?"、"&"、"="等任何与参数相关的字符
         * （3）若上述格式全部满足，仍然找不到文件，则报错并返回404
         */
        String sUrl(url);

        if (sUrl.matchCase("?") || sUrl.matchCase("&") || sUrl.matchCase("="))
        {
                return false;
        }

        return true;
}

void WHPSHttpParser::getHeaderInfo(SpVector& vrow_seq, HttpRequestContext& context)
{
        int count = -1;

        // for (SpVector::iterator it = vrow_seq.begin(); it != vrow_seq.end(); ++it)
        for (auto& seq_line: vrow_seq)  // 遍历行序列
        {
                count++;
                if (seq_line == "\0")   // 可能出现空行，调过解析
                {
                        continue;
                }

                /* 将每一行，按照指定符号拆分成map k-v键值对形式 */
                GetSplit(context, seq_line);
        }

        vrow_seq.erase(vrow_seq.begin(), vrow_seq.begin()+count);
}

bool WHPSHttpParser::getBodyInfo(SpVector& vrow_seq, HttpRequestContext& context)
{
        /* GET和DELETE方法没有请求消息体
         */
        const string& method = context.getMethod();
        if (method == "GET" || method == "DELETE")
        {
                return true;
        }

        if (!GetContact(context, vrow_seq))
        {
                return false;
        }

        return true;
}

#include "WHPSHttpServer.h"

// WHPSHttpServer* WHPSHttpServer::_http_server = NULL;
std::shared_ptr<WHPSHttpServer> WHPSHttpServer::_http_server;

WHPSHttpServer::WHPSHttpServer()
        : _tcp_server(GetWHPSTcpServer())
{
        _tcp_server->setNewConnCallback(std::bind(&WHPSHttpServer::onNewConnection, this, std::placeholders::_1));
        // _tcp_server->setNewCloseCallback(std::bind(&WHPSHttpServer::onNewClose, this, std::placeholders::_1));
}

WHPSHttpServer::~WHPSHttpServer()
{
        cout << "WHPSHttpServer::~WHPSHttpServer" << endl;
}

/*static */
WHPSHttpServer& WHPSHttpServer::GetInstance()
{
        // if (!_http_server.get())
        if (!_http_server)
        {
                _http_server = std::shared_ptr<WHPSHttpServer>(new WHPSHttpServer());
        }

        return *_http_server.get();
}

/* 启动http服务 */
void WHPSHttpServer::start()
{
        _tcp_server->start();
        _tcp_server->startLoop();
}

void WHPSHttpServer::onNewConnection(const sp_TcpSession& tcp_session)
{
        this->onNewSession(tcp_session);
}

void WHPSHttpServer::onNewSession(const sp_TcpSession& tcp_session)
{
        cout << "WHPSHttpServer::onNewConnection: " << tcp_session->getNetInfo() << endl;
        sp_HttpSession http_session(new WHPSHttpSession(tcp_session));
        http_session->setHttpCloseCallback(std::bind(&WHPSHttpServer::onNewClose, this, std::placeholders::_1));
        char addr[1024] = {0};
        sprintf(addr, "%ld", (long)tcp_session.get());
        string str(addr);
        _http_sess_list[tcp_session->getNetInfo() + str] = http_session;
}

void WHPSHttpServer::onNewClose(const sp_TcpSession& tcp_session)
{
        char addr[1024] = {0};
        sprintf(addr, "%ld", (long)tcp_session.get());
        string str(addr);
        _http_sess_list.erase(tcp_session->getNetInfo() + str);
        cout << "WHPSHttpServer::onNewClose-----size: " << _http_sess_list.size() << endl;
}

#include <unistd.h>     // for sleep
#include <iostream>
#include <thread>
#include <sstream>
#include <fstream>
#include <sys/stat.h>   // for fstat

#include "WHPSHttpSession.h"
#include "util.h"
#include "WHPSConfig.h"

#include "WhpsObject.h"

using namespace std;     

WHPSHttpSession::WHPSHttpSession(const sp_TcpSession _tcp_session)
        : _tcp_session(_tcp_session)
        , _obj_name(GetWebSourceConfig().get("whps", "whps-name"))
        , _whps_static_processor(GetWebSourceConfig().get("StaticResource", "rootDir"))    // 静态资源处理器
        , _http_whps_factory(GetHttpWhpsFactory())          // 获取单例工厂句柄
        , _http_whps(_http_whps_factory->get(_obj_name))    // 获取应用层回调句柄
{
        _writer_func = std::bind(&WHPSHttpSession::sendHttpMessage, this, std::placeholders::_1);
        // 注册http响应消息回调
        _writer.registObj(std::bind(&WHPSHttpSession::sendHttpMessage, this, std::placeholders::_1));
        _tcp_session->setHttpMessageCallback(std::bind(&WHPSHttpSession::onHttpMessage, this));
        _tcp_session->setHttpSendCallback(std::bind(&WHPSHttpSession::onHttpSend, this));
        _tcp_session->setHttpCloseCallback(std::bind(&WHPSHttpSession::onHttpClose, this));
        _tcp_session->setHttpErrorCallback(std::bind(&WHPSHttpSession::onHttpClose, this));
}

WHPSHttpSession::~WHPSHttpSession()
{
        // if (_http_whps)
        // {
        //         delete _http_whps;
        //         _http_whps = NULL;  // 后续加到工厂中释放资源
        // }
}

const WHPSHttpSession::sp_TcpSession& WHPSHttpSession::getTcpSession() const
{
        return _tcp_session;
}

void WHPSHttpSession::setHttpCloseCallback(HttpSessionCB_ cb)
{
        _http_closeCB = cb;
}

void WHPSHttpSession::onHttpMessage()
{
        cout << "WHPSHttpSession::onHttpMessage" << endl;
        HttpRequestContext context;
        HttpResponseContext response(_writer_func);
#if 1
        _http_whps = _http_whps_factory->get(_obj_name);
        if (!_http_whps)
        {
                cout << "WHPSHttpSession::onHttpMessage whps object is not callable...." << endl;
                this->notifyToClose();

                return;
        }
#endif

        _http_parser.parseHttpRequest(_tcp_session->getBufferIn(), context);     // 解析获取http请求内容

        this->onCallback(context, response);    // 调用消息回调处理程序
}

void WHPSHttpSession::onHttpSend()
{
        _tcp_session->getBufferIn().clear();     // 假设已经处理完毕
}

void WHPSHttpSession::onHttpClose()
{
        _http_closeCB(_tcp_session);
}

void WHPSHttpSession::onHttpError()
{
        cout << "WHPSHttpSession::onHttpError" << endl;
        _http_closeCB(_tcp_session);
}

void WHPSHttpSession::notifyToClose()
{
        /* 当响应头中包含 Connection: close 的时候，需要服务端主动关闭连接
         */
        _tcp_session->close();
}

void WHPSHttpSession::sendHttpMessage(const string& msg)
{
        _tcp_session->send(msg);
}

void WHPSHttpSession::onCallback(HttpRequestContext& request, HttpResponseContext& response)
{
        /* 调用处理部分逻辑 */
        if (request.getFlag())      // 静态资源
        {
                this->onStaticRequest(request, response);
        }
        else
        {
                this->onDynamicRequest(request, response);
        }
}

void WHPSHttpSession::onStaticRequest(HttpRequestContext& request, HttpResponseContext& response)
{
        /* 框架请求静态资源，仅支持 GET 方法获取
         * 不支持也没必要支持 POST、DELETE
         */
        if (request.getMethod() == "GET")
        {
                _whps_static_processor.doGet(request, response);    // 通过静态资源处理器直接返回
                // this->notifyToClose();
        }
        else
        {
                cout << "WHPSHttpSession::onStaticRequest not support method: [" << request.getMethod() << "]" << endl;
        }
}

void WHPSHttpSession::onDynamicRequest(HttpRequestContext& request, HttpResponseContext& response)
{
        const string& method = request.getMethod();

        if (method == "GET" || method == "DELETE")
        {
                _http_whps->doGet(request, response);
        }
        else if (method == "POST" || method == "PUT")
        {
                _http_whps->doPost(request, response);
        }
        else
        {
                cout << "WHPSHttpSession::onDynamicRequest not support method: [" << method << "]" << endl;
        }
}

/*  */
static int load(const string& filename, string& f_buff);

WhpsSysResource::WhpsSysResource(const string& rootPath)
        : _rootPath(rootPath)
{

}

WhpsSysResource::~WhpsSysResource()
{

}

void WhpsSysResource::doGet(HttpWhpsRequest request, HttpWhpsResponse response)
{
        /* 静态资源自动加载功能（通过配置，获取静态资源路径，并写回给前端）
         */
        string path = _rootPath + request.getUrl();
        string msg;
        this->getResouceFile(path, msg);

        response.getWriter().write(msg);
}

void WhpsSysResource::getResouceFile(const string& path, string& msg)
{
        cout << "WhpsSysResource::getResouceFile path: " << path << endl;
        int res = load(path, msg);

        if (res < 0)
        {
                string tmp = "404 not found!";
                msg = "HTTP/1.1 404 not found \r\n"
                      "Content-Length: " + to_string(tmp.size()) + "\r\n"
                      "\r\n"
                      + tmp;
        }
}

/* 获取文件大小 */
static size_t getFileTotalSize(const ifstream& in)
{
/*
        struct stat {
               dev_t     st_dev;     // ID of device containing file 
               ino_t     st_ino;     // inode number 
               mode_t    st_mode;    // protection 
               nlink_t   st_nlink;   // number of hard links 
               uid_t     st_uid;     // user ID of owner 
               gid_t     st_gid;     // group ID of owner 
               dev_t     st_rdev;    // device ID (if special file) 
               off_t     st_size;    // total size, in bytes 
               blksize_t st_blksize; // blocksize for file system I/O 
               blkcnt_t  st_blocks;  // number of 512B blocks allocated 
               time_t    st_atime;   // time of last access 
               time_t    st_mtime;   // time of last modification 
               time_t    st_ctime;   // time of last status change 
        };
 */
        struct stat stat__;

        /* std::filebuf: 流缓冲区用于读取和写入文件。 */
        auto getFd = [](std::filebuf& fbuff) -> int
        {
                // 继承自std::filebuf，才能使用_M_file protected成员
                struct Helper : public std::filebuf
                {
                        int Handle()
                        {
                                return _M_file.fd(); 
                        }
                };
            
                return static_cast<Helper&>(fbuff).Handle();
        };

        int fd = getFd(*in.rdbuf());
        fstat(fd, &stat__);

        return stat__.st_size;
}

/* 读取指定文件到缓冲buff */
int load(const string& filename, string& f_buff)
{
        std::ifstream in;   
        in.open(filename, std::ios::in | std::ios::binary);      // open input file

        if (!in)
        {
                return -1;
        }

        
        size_t length = getFileTotalSize(in);

        char *buffer = new char[length];    // allocate memory for a buffer of appropriate dimension  
        in.read(buffer, length);       // read the whole file into the buffer  
        in.close();

#if 1
        f_buff = "HTTP/1.1 200 OK \r\n"
//                 "Connection:close \r\n"
                // "Content-Type:application/x-gzip\r\n"
//                  "Content-Type:text/html\r\n"
                 "Content-Length: " + to_string(length) + "\r\n"
                 "\r\n";
#endif
        f_buff += string(buffer, length);
        delete[] buffer;

        return 0;
}

#include "WHPSRequest.h"

using namespace std;

HttpRequestContext::HttpRequestContext()
{

}

HttpRequestContext::~HttpRequestContext()
{

}

const string& HttpRequestContext::getMethod()
{
        return this->_getMethod();
}

const string& HttpRequestContext::getUrl()
{
        return this->_getUrl();
}

const string& HttpRequestContext::getVersion()
{
        return this->_getVersion();
}

HttpRequestHeader& HttpRequestContext::getHeader()
{
        return this->_getHeader();
}

const string& HttpRequestContext::getBody()
{
        return this->_getBody();
}

const bool& HttpRequestContext::getFlag()
{
        return this->_getFlag();
}

void HttpRequestContext::setMethod(const std::string& method)
{
        this->_setMethod(method);
}

void HttpRequestContext::setUrl(const std::string& url)
{
        this->_seturl(url);
}

void HttpRequestContext::setVersion(const std::string& version)
{
        this->_setVersion(version);
}

void HttpRequestContext::setHeader(const std::string& k, const std::string& v)
{
        this->_setHeader(k, v);
}

void HttpRequestContext::setBody(const std::string& body)
{
        this->_setBody(body);
}

void HttpRequestContext::setFlag(const bool& flag)
{
        this->_setFlag(flag);
}

#include "WHPSRequestWrapper.h"

using namespace std;

WHPSRequestWrapper::WHPSRequestWrapper()
{

}

WHPSRequestWrapper::~WHPSRequestWrapper()
{

}

const string& WHPSRequestWrapper::_getMethod()
{
        return _method;
}

const string& WHPSRequestWrapper::_getUrl()
{
        return _url;
}

const string& WHPSRequestWrapper::_getVersion()
{
        return _version;
}

HttpRequestHeader& WHPSRequestWrapper::_getHeader()
{
        return _header;
}

const string& WHPSRequestWrapper::_getBody()
{
        return _body;
}

const bool& WHPSRequestWrapper::_getFlag()
{
        return _isStatic;
}

void WHPSRequestWrapper::_setMethod(const string& method)
{
        _method = method;
}

void WHPSRequestWrapper::_seturl(const string& url)
{
        _url = url;
}

void WHPSRequestWrapper::_setVersion(const string& version)
{
        _version = version;
}

void WHPSRequestWrapper::_setHeader(const string& k, const string& v)
{
        _header[k] = v;
}

void WHPSRequestWrapper::_setBody(const string& body)
{
        _body = body;
}

void WHPSRequestWrapper::_setFlag(const bool& flag)
{
        _isStatic = flag;
}

#include "WHPSResponse.h"

using namespace std;

HttpResponseContext::HttpResponseContext(cbFunc cb)
        : WHPSResponseWrapper(cb)
{

}

HttpResponseContext::~HttpResponseContext()
{

}

WhpsWriter& HttpResponseContext::getWriter()
{
        return this->getResponse()._getWriter();
}

HttpResponseContext& HttpResponseContext::getResponse()
{
        return (HttpResponseContext&)*this->_getResponse();
}

void HttpResponseContext::setContentLength(const string& length)
{
        this->getResponse()._setContentLength(length);
}

void HttpResponseContext::setContentType(const string& type)
{
        this->getResponse()._setContentType(type);
}

void HttpResponseContext::addHeader(const string& h_key, const string& h_value)
{
        this->getResponse()._addHeader(h_key, h_value);
}

void HttpResponseContext::addIntHeader(const string& h_key, const int& h_value)
{
        this->getResponse()._addIntHeader(h_key, h_value);
}

void HttpResponseContext::addDateHeader(const string& h_key, const long& h_value)
{
        this->getResponse()._addDateHeader(h_key, h_value);
}

void HttpResponseContext::setHeader(const string& h_key, const string& h_value)
{
        this->getResponse()._setHeader(h_key, h_value);
}

void HttpResponseContext::setIntHeader(const string& h_key, const int& h_value)
{
        this->getResponse()._setIntHeader(h_key, h_value);
}

void HttpResponseContext::setDateHeader(const string& h_key, const long& h_value)
{
        this->getResponse()._setDateHeader(h_key, h_value);
}

string HttpResponseContext::getHeader()
{
        return this->getResponse()._getHeader();
}

#include "WHPSResponseWrapper.h"

using namespace std;

WHPSResponseWrapper::WHPSResponseWrapper(cbFunc cb)
        : _version("HTTP/1.1")
        , _st_code("200")
        , _status("OK")
        , _writer(cb)
{
        this->initParams();
}

WHPSResponseWrapper::~WHPSResponseWrapper()
{

}

void WHPSResponseWrapper::initParams()
{
        _header["Content-Type"] = "text/html;charset=UTF-8";
}

WHPSResponseWrapper* WHPSResponseWrapper::_getResponse()
{
        return this;
}

void WHPSResponseWrapper::_setContentLength(const std::string& length)
{
        _header["Content-Length"] = length;
}

void WHPSResponseWrapper::_setContentType(const std::string& type)
{
        _header["Content-Type"] = type;
}

void WHPSResponseWrapper::_addHeader(const std::string& h_key, const std::string& h_value)
{
        _header[h_key] = h_value;
}

void WHPSResponseWrapper::_addIntHeader(const std::string& h_key, const int& h_value)
{
        _header[h_key] = to_string(h_value);
}

void WHPSResponseWrapper::_addDateHeader(const std::string& h_key, const long& h_value)
{

}

void WHPSResponseWrapper::_setHeader(const std::string& h_key, const std::string& h_value)
{
        _header[h_key] = h_value;
}

void WHPSResponseWrapper::_setIntHeader(const std::string& h_key, const int& h_value)
{
        _header[h_key] = to_string(h_value);
}

void WHPSResponseWrapper::_setDateHeader(const std::string& h_key, const long& h_value)
{

}

string WHPSResponseWrapper::_getHeader()
{
        string header;
        for (auto& kv: _header)
        {
                header += kv.first + ": " + kv.second + "\r\n";
        }

        return header;
}

WhpsWriter& WHPSResponseWrapper::_getWriter()
{
        return _writer;
}

#include <iostream>
#include "WhpsWriter.h"

using namespace std;

WhpsWriter::WhpsWriter(cbFunc cb)
        : _cb_func(cb)
{

}

WhpsWriter::~WhpsWriter()
{
        
}

void WhpsWriter::write(const string& msg)
{
        if (_cb_func)
        {
                _cb_func(msg);
        }
}

#include "HttpWhpsFactory.h"

#ifdef __GNUC__
#include <cxxabi.h>
#endif
#include <stdlib.h>

std::shared_ptr<HttpWhpsFactory> HttpWhpsFactory::_http_whps_factory;

HttpWhpsFactory::HttpPtrType HttpWhpsFactory::get(const std::string& type)
{
        return _map_ptr[type];
}

bool HttpWhpsFactory::create(const std::string& type_name)
{
        HttpPtrType obj = _create(type_name);
        
        if (!obj)
        {
                return false;
        }

        cout << "HttpWhpsFactory::create: " << type_name << endl;
        _map_ptr[type_name] = obj;

        return true;
}

HttpWhpsFactory::HttpPtrType HttpWhpsFactory::_create(const std::string & type_name)
{
        if (type_name.empty())
        {
                return NULL;
        }

        std::map<std::string, CreateFunction>::iterator it = _create_function_map.find(type_name);
        
        if (it == _create_function_map.end())
        {
                return NULL;
        }
        
        return it->second();
}

// 解析类型名称（转换为 A::B::C 的形式）
std::string HttpWhpsFactory::readTypeName(const char* name)
{
        char* real_name = abi::__cxa_demangle(name, nullptr, nullptr, nullptr);
        std::string real_name_string(real_name);
        ::free(real_name);

        return real_name_string;
}

bool HttpWhpsFactory::regist(const char * name, CreateFunction func)
{
        if (!func)
        {
                cout << "HttpWhpsFactory::regist false" << endl;

                return false;
        }

        std::string type_name = readTypeName(name);
        _create_function_map.insert(type_name, func);
        
        return this->create(type_name);
}

#include "WhpsObjRegisterBase.h"

WhpsObjRegisterBase::WhpsObjRegisterBase() 
{

}

WhpsObjRegisterBase::~WhpsObjRegisterBase() 
{
        
}

void WhpsObjRegisterBase::registObj(cbFunc cb)
{
        // pass
}

WhpsObjRegisterBase::cbFunc WhpsObjRegisterBase::getRegistObj()
{
        // pass
        return NULL;
}
#ifndef __CODEC_H__
#define __CODEC_H__

#include <string>

/* 字符编解码器
 * 提供直接调用的编解码接口
 */
class Codec
{

public:
        /* 字符串编码
         */
        static std::string encode(const std::string& str, const std::string& type = "utf-8");
        
        /* 字符串解码
         */
        static std::string decode(const std::string& str, const std::string& type = "utf-8");

private:
        static std::string urlEncode(const std::string& str);
        
        static std::string urlDecode(const std::string& str);
};

#endif  // __CODEC_H__
#ifndef __CPP_THREAD_H__
#define __CPP_THREAD_H__

#include <thread>

#include "ImplThread.h"
#include "Task.h"

// typedef std::thread::id thread__id;

/* c++版本的线程
 * 实现了线程创建、销毁和启停动作的功能
 */
class CPPThread : public ImplThread
{
public:
        using task_t = task_func_t;
        using impl_task_func_t = __impl_task_func_t;
public:
        CPPThread(Task<task_t>& task);
        virtual ~CPPThread();

public:
        /* 启动线程 */
        virtual void start();
        virtual void start(impl_task_func_t callback);

        /* 停止线程 */
        virtual void stop();

        /* 等待线程结束，回收资源 */
        virtual void join();

        /* 获取当前线程的id号 */
        virtual const thread__id& getId() const;

public:
        /* 线程执行函数 */
        void workFunc();

        void excuteTask();

private:
        /* 线程进入执行函数后的一些初始化 */
        virtual void init();
private:
        std::thread __thrd;     // 线程句柄
        thread__id  __tid;      // 线程id
        bool __is_stop;         // 线程退出标志

private:
        Task<task_t>& _task;    // 任务队列(共享线程池中的队列)
};

#endif  // __CPP_THREAD_H__
#ifndef __IMPL_EVENT_HANDLER_H__
#define __IMPL_EVENT_HANDLER_H__

#include <functional>

#define __stdcall
/*
 * 事件回调抽象接口，包含：
 *      类型声明、回调接口声明、epoll事件类型、提供当前子类对应的句柄描述符等。
 * 任何回调事件的触发都是通过__fd完成；
 * 任何与__fd相关的回调，都是用过epoll events来触发。
 */
class ImplEventHandler
{
public: // 类型定义
        /* 预定义回调函数类型 */
        using __callback_t = std::function<void()>;
        using __epoll_events_t = unsigned int;

public:
        virtual ~ImplEventHandler()
        {

        }

protected:
        /* 设置当前处理的句柄描述符 */
        void __setFd(int fd)
        {
                __fd = fd;
        }

        /* 获取已设置的句柄描述符 */
        const int& __getFd()
        {
                return __fd;
        }

        /* 设置epoll事件类型宏 */
        void __setEvents(__epoll_events_t events)
        {
                __epoll_events = events;
        }

        /* 获取epoll事件类型宏 */
        const __epoll_events_t& __getEvents() const
        {
                return __epoll_events;
        }

        /* 设置回调函数接口 */
        virtual void __stdcall __setCallback(__callback_t& __cb_s, __callback_t __cb_d) = 0;

        /* 执行回调函数接口 */
        virtual void __stdcall __exCallback() = 0;

private:
        /* 该父类的派生类所拥有的句柄描述符。
         * 任何的事件处理都是基于句柄描述符，该描述符的值应与外部统一。
         */
        int __fd;

        /* epoll事件类型，其值类型为 enum EPOLL_EVENTS */
        __epoll_events_t __epoll_events;
};

#endif  // __IMPL_EVENT_HANDLER_H__

#ifndef __IMPL_THREAD_H__
#define __IMPL_THREAD_H__

#include <functional>

typedef unsigned int thread__id;
typedef std::function<void()> __impl_task_func_t;

/* 线程(虚)接口类
 * 子类可以是c语言版的线程，也可以是c++版本的线程
 */
class ImplThread
{
public:
        virtual inline ~ImplThread()
        {

        }

        /* 启动线程
         * 一般进行对线程执行状态标志位置位、初始化参数等操作
         */
        virtual void start() = 0;
        virtual void start(__impl_task_func_t __callback) = 0;  // 可以设置线程的执行函数

        /* 停止线程
         * 一般进行对线程执行状态标志位初始化操作
         */
        virtual void stop() = 0;

        /* 等待线程结束，回收资源 */
        virtual void join() = 0;

        /* 获取当前线程的id号 */
        virtual const thread__id& getId() const = 0;

public:
        /* 线程执行函数(c和c++对于执行函数的参数和返回值都不同，这里不做统一) */
        //virtual void workFunc() = 0;

        /* 线程进入执行函数后的一些初始化 */
        virtual void init() = 0;
};

#endif  // __IMPL_THREAD_H__
#ifndef __IMPL_THREAD_POLL_H__
#define __IMPL_THREAD_POLL_H__

/* 线程池接口类，具体线程吃的实现，继承此可有多种方法
 */
class ImplThreadPool
{
public:
        /* 所有线程开始执行任务 */
        virtual void start() = 0;

private:
        /* 创建一定数量的线程 */
        virtual void createThreads() = 0;

        /* 所有线程停止执行任务，释放资源并退出 */
        virtual void stop() = 0;
};

#endif  // __IMPL_THREAD_POLL_H__
#ifndef __POLLER_H__
#define __POLLER_H__

#include <sys/epoll.h>

#define INVALID_EPOLLFD    -1
typedef struct epoll_event SEplEvent;

/*
 * 基础epoll类，该类实现对linux系统库中，epoll基本功能的封装。
 * 该类仅提供基本接口，不负责维护相关的数据结构。
 */
class Poller
{
public:
        Poller(int maxevents, int timeout);
        ~Poller();

public:
        int __poll(SEplEvent* events);

        /* 添加事件，EPOLL_CTL_ADD */
        int __addEvent(const int& fd, SEplEvent& ev);

        /* 移除事件，EPOLL_CTL_DEL */
        int __delEvent(const int& fd, SEplEvent& ev);

        /* 修改事件，EPOLL_CTL_MOD */
        int __updateEvent(const int& fd, SEplEvent& ev);

        /* 设置epoll事件等待超时时间 */
        void __setTimeout(int timeout);

private:
        int __poll_fd;          // epoll实例句柄
        int __maxevents;
        int __timeout;
};

#endif  // __EPOLLER_H__

#ifndef __SOCKET_H__
#define __SOCKET_H__

#include <stdio.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <arpa/inet.h>

#define INVALID_SOCK    -1
#define LISTEN_SIZE     8192

/*
 * 基础socket类，该类实现对linux系统库中，socket基本功能的封装。
 */
class Socket
{
public:
        Socket();
        virtual ~Socket();

        /* 获取当前socket句柄 */
        const int& __get() const;

        /* 判断当前socket是否有效 
         * 返回：
         *      true：表示为有效socket
         *      false：表示为无效socket
         */
        bool __isValid();
protected:
        /* 设置socket，适用于服务器接收的客户端socket */
        void __set(int fd);
        
        /* 设置socket属性 */
        int __setSocketOpt();

        /* 设置非阻塞socket */
        int __setNonblock();

        /* 创建一个socket */
        int __socket();

        /* 绑定一个端口
         *      server模式：ip地址无需传递
         *      client模式：ip地址需传指定的服务器ip
         */
        int __bind(const int& port, const char* ip = NULL);

        /* 启动监听 */
        int __listen();

        /* 获取被监听的连接请求 */
        int __accept();   // 暂时不用
        int __accept(struct sockaddr_in& c_addr);         // 优先实现这个接口
        struct sockaddr_in __accpet();    // 暂时不用

        /* 设置socket地址重用(主要用于服务端socket) */
        int __setReuseAddr();

        /* 关闭socket */
        int __close();

private:
        int __socket_fd;         // 句柄文件描述符
};

#endif  // __SOCKET_H__

#ifndef __TASK_H__
#define __TASK_H__

#include <queue>
#include <mutex>
#include <functional>

using task_func_t = std::function<void()>;

/* 线程任务类
 * 考虑到可能有不同类型的线程池，因此将任务类型做成模板，以匹配任何的数据类型
 */
template <class T>
class Task
{
public:
        Task()
                : __tq_size(0)
        {

        }

        ~Task()
        {

        }

public:
        /* 当前锁是对队列操作的全局锁，数据量大时，效率低
         * 后面设计成局部锁，或更改逻辑使得不需要加锁
         */
        /* 向任务队列添加一个任务 */
        inline void addTask(T task)
        {
                std::lock_guard<std::mutex> lock(__q_mutex);
                __tq.push(task);
                __tq_size++;    // 任务数加1
        }

        /* 从任务队列获取一个任务 */
        inline T get()
        {
                std::lock_guard<std::mutex> lock(__q_mutex);
                T task;

                if (__tq_size)
                {
                        task = __tq.front();
                        __tq.pop();          // 是否要保证任务成功执行再删除(待定)
                        __tq_size--;    // 任务数减1
                }

                return task;
        }

        /* 获取当前Task队列的任务数 */
        const size_t& size() const
        {
                return __tq_size;
        }

private:
        std::queue<T> __tq;     // 任务队列
        std::mutex __q_mutex;   // 任务锁
        size_t     __tq_size;   // 任务量
};

#endif  // __TASK_H__
#ifndef __THREAD_POOL_H__
#define __THREAD_POOL_H__

#include <vector>

#include "ImplThreadPool.h"
#include "CPPThread.h"

#include "Task.h"

/* 线程池类
 * 可创建指定数量的线程，启动、销毁等线程的管理
 */
class ThreadPool : public ImplThreadPool
{
public:
        /* 线程池入口，可设置工作线程数量 */
        explicit ThreadPool(int size);
        explicit ThreadPool(int size, task_func_t callback);    // 可以设置线程的执行函数
        
        virtual ~ThreadPool();

public:
        /* 所有线程开始执行任务 */
        virtual void start();

        /* 测试接口：主线程向队列中添加任务，由所有子线程来执行 */
        void testTask(task_func_t task)
        {
                __task.addTask(task);
        }

private:
        /* 创建一定数量的线程 */
        virtual void createThreads();

        /* 所有线程停止执行任务，释放资源并退出 */
        virtual void stop();

private:
        int __size;     // 线程数量
        task_func_t     __callback;             // 记录线程的执行函数
        std::vector<ImplThread*> __v_th;        // 线程列表

        Task<task_func_t> __task;          // 线程任务(当前是所有线程共享一个任务队列)
};

#endif  // __THREAD_POOL_H__
#include <iostream>

#include "Codec.h"

using namespace std;

char toHex(char x) 
{ 
        return  x > 9 ? x + 55 : x + 48; 
}
 
char fromHex(char x) 
{ 
        unsigned char y = 0;
        if (x >= 'A' && x <= 'Z') 
        {
                y = x - 'A' + 10;
        }
        else if (x >= 'a' && x <= 'z') 
        {
                y = x - 'a' + 10;
        }
        else if (x >= '0' && x <= '9') 
        {
                y = x - '0';
        }
        else 
        {
                // pass
        }

        return y;
}

string Codec::encode(const string& str, const string& type)
{
        string str_ = str;

        if (type == "utf-8")
        {

        }
        else if (type == "UrlCode")
        {
                str_ = urlEncode(str);
        }
        else
        {
                cout << "String not support encode this type: [" + type + "]" << endl;
        }

        return str_;
}
        
string Codec::decode(const string& str, const string& type)
{
        string str_ = str;

        if (type == "utf-8")
        {

        }
        else if (type == "UrlCode")
        {
                str_ = urlDecode(str);
        }
        else
        {
                cout << "String not support decode this type: [" + type + "]" << endl;
        }

        return str_;
}

string Codec::urlEncode(const string& str)
{
        std::string stmp = "";
        size_t length = str.length();

        for (size_t i = 0; i < length; i++)
        {
                if (isalnum((unsigned char)str[i]) 
                    || (str[i] == '-') 
                    ||(str[i] == '_') 
                    || (str[i] == '.') 
                    || (str[i] == '~'))
                {
                        stmp += str[i];
                }
                else if (str[i] == ' ')
                {
                        stmp += "+";
                }
                else
                {
                        stmp += '%';
                        stmp += toHex((unsigned char)str[i] >> 4);
                        stmp += toHex((unsigned char)str[i] % 16);
                }
        }

        return stmp;
}

string Codec::urlDecode(const string& str)
{
        std::string stmp = "";
        size_t length = str.length();

        for (size_t i = 0; i < length; i++)
        {
                if (str[i] == '+') 
                {
                        stmp += ' ';
                }
                else if (str[i] == '%')
                {
                        // assert(i + 2 < length);
                        if ((i+2) >= length)
                        {
                                break;
                        }

                        unsigned char high = fromHex((unsigned char)str[++i]);
                        unsigned char low = fromHex((unsigned char)str[++i]);
                        stmp += high*16 + low;
                }
                else 
                {
                        stmp += str[i];
                }
        }

        return stmp;
}

#include <iostream>
#include <unistd.h>
using namespace std;

#include "CPPThread.h"

CPPThread::CPPThread(Task<task_t>& task)
        : __is_stop(false)
        , _task(task)
{

}

CPPThread::~CPPThread()
{
        // this->join();
}

void CPPThread::start()
{
        __thrd = std::thread(std::bind(&CPPThread::workFunc, this));
        this->init();
}

void CPPThread::start(impl_task_func_t callback)
{
        __thrd = std::thread(callback);
        this->init();
}

void CPPThread::stop()
{
        __is_stop = true;
}

void CPPThread::join()
{
        if (!__is_stop)
        {
                this->stop();
                __thrd.join();
        }
}

const thread__id& CPPThread::getId() const
{
        return __tid;
}

void CPPThread::init()
{
        /* 基类统一tid的数据类型，因此使用std::hash，将c++版的线程id，转换成可与c版本的通用类型：unsigned int */
        __tid = std::hash<std::thread::id>()(__thrd.get_id());
        __is_stop = false;
}

void CPPThread::excuteTask()
{
        /* 执行所有任务 */

        for (size_t i = 0; i < _task.size(); i++)
        {
                task_t task = _task.get();

                if (task)       // 有可能存在取空的情况，因此加上判断，防止执行空函数
                {
                        task();
                }
        }
}

#if 1
void CPPThread::workFunc()
{
        /* 每个线程在执行函数中，仅仅关心队列中的任务，不需要关心任务的来源 */

        while (!__is_stop)
        {
                usleep(10);     // 延迟后面可去掉，因为一次http业务处理远比10us长
                task_t task = _task.get();
                // task();
                if (task)       // 有可能存在取空的情况，因此加上判断，防止执行空函数
                {
                        task();
                }
        }
}
#endif

#include "Poller.h"
#include "util.h"

Poller::Poller(int maxevents, int timeout)
        : __poll_fd(INVALID_EPOLLFD), __maxevents(maxevents), __timeout(timeout)
{
        __poll_fd = epoll_create(1024);

        if (__poll_fd == INVALID_EPOLLFD)
        {
                exitService(INVALID_EPOLLFD);
        }
}

Poller::~Poller()
{
        
}

#include <iostream>
using namespace std;
int Poller::__poll(SEplEvent* events)
{
        // cout << ">>>>>>>>>>>epoll_wait timeout: " << __timeout << endl;
        return epoll_wait(__poll_fd, events, __maxevents, __timeout);
}

int Poller::__addEvent(const int& fd, SEplEvent& ev)
{
        return epoll_ctl(__poll_fd, EPOLL_CTL_ADD, fd, &ev);
}

int Poller::__delEvent(const int& fd, SEplEvent& ev)
{
        return epoll_ctl(__poll_fd, EPOLL_CTL_DEL, fd, &ev);
}

int Poller::__updateEvent(const int& fd, SEplEvent& ev)
{
        return epoll_ctl(__poll_fd, EPOLL_CTL_MOD, fd, &ev);
}

void Poller::__setTimeout(int timeout)
{
        __timeout = timeout;
}

#include <stdio.h>      // for NULL

// for fcntl
#include <unistd.h>
#include <fcntl.h>
// -----------------

#include <string.h>     // for memset
#include <unistd.h>
#include <stdlib.h>

#include <iostream>
using namespace std;

#include "Socket.h"

Socket::Socket()
        : __socket_fd(INVALID_SOCK)
{
        
}

Socket::~Socket()
{
        if (__socket_fd != INVALID_SOCK)
        {
                this->__close();
                __socket_fd = INVALID_SOCK;
        }
}

void Socket::__set(int fd)
{
        __socket_fd = fd;
}

#include <netinet/tcp.h> // for TCP_NODELAY
int Socket::__setSocketOpt()
{
        int on = 1;
        setsockopt(__socket_fd, SOL_SOCKET, SO_KEEPALIVE, (void*)&on, sizeof(on));
        setsockopt(__socket_fd, IPPROTO_TCP, TCP_NODELAY, (void*)&on, sizeof(on));
        setsockopt(__socket_fd, SOL_TCP, TCP_NODELAY, (void*)&on, sizeof(on));

        return 0;
}

const int &Socket::__get() const
{
        return __socket_fd;
}

bool Socket::__isValid()
{
        if (__socket_fd == INVALID_SOCK)         // 无效的s
        {
                return false;
        }

        return true;
}

int Socket::__setNonblock()
{
        int flag = fcntl(__socket_fd, F_GETFL, 0);

        if (flag >= 0)
        {
                if (fcntl(__socket_fd, F_SETFL, flag | O_NONBLOCK) >= 0)
                {
                        return 0;
                }
        }

        return -1;
}

int Socket::__socket()
{
        __socket_fd = socket(AF_INET, SOCK_STREAM, 0);
        return __socket_fd;
}

int Socket::__bind(const int &port, const char *ip)
{
        struct sockaddr_in so_addr;
        memset(&so_addr, 0, sizeof(so_addr));
        so_addr.sin_family = AF_INET;   // 设置地址族
        so_addr.sin_port = htons(port);         // 绑定端口

        if (ip)        // 客户端绑定地址
        {
                so_addr.sin_addr.s_addr = inet_addr(ip);
        }
        else            // 服务器绑定地址
        {
                so_addr.sin_addr.s_addr = htonl(INADDR_ANY);
        }

        int res = bind(__socket_fd, (struct sockaddr*)&so_addr, sizeof(so_addr));

        return res;
}

int Socket::__listen()
{
        return listen(__socket_fd, LISTEN_SIZE);
}

/* 暂时不用 */
int Socket::__accept()
{
        return 0;
}

int Socket::__accept(struct sockaddr_in &c_addr)
{
        socklen_t addr_len = sizeof(c_addr);
        return accept(__socket_fd, (struct sockaddr*)&c_addr, &addr_len);
}

/* 暂时不用 */
struct sockaddr_in Socket::__accpet()
{
        struct sockaddr_in clientaddr;
        return clientaddr;
}

int Socket::__setReuseAddr()
{
        int v = 1;
        return setsockopt(__socket_fd, SOL_SOCKET, SO_REUSEADDR, &v, sizeof(v));
}

int Socket::__close()
{
        if (!close(__socket_fd))         // 关闭成功
        {
                __socket_fd = INVALID_SOCK;
                return 0;
        }

        return -1;                      // 关闭失败
}

#include <iostream>
#include "ThreadPool.h"

using namespace std;

#define MAX_THREAD      100

ThreadPool::ThreadPool(int size)
        : __size(size)
{
        this->createThreads();

        if (__size > 100)
        {
                cout << "too many threads, exit..." << endl;
                exit(-1);
        }
}

ThreadPool::ThreadPool(int size, task_func_t callback)
        : __size(size)
        , __callback(callback)
{
        this->createThreads();

        if (__size > 100)
        {
                cout << "too many threads, exit..." << endl;
                exit(-1);
        }
}

ThreadPool::~ThreadPool()
{
        this->stop();
}

void ThreadPool::start()
{
        for (int i = 0; i < __size; i++)
        {
                __v_th[i]->start(__callback);
        }
}

void ThreadPool::stop()
{
        for (int i = 0; i < __size; i++)
        {
                // __v_th[i]->stop();
                delete __v_th[i];
        }
}

void ThreadPool::createThreads()
{
        for (int i = 0; i < __size; i++)
        {
                ImplThread* th = new CPPThread(__task);
                __v_th.push_back(th);
        }
}
#ifndef __IMPL_SINGLETON_H__
#define __IMPL_SINGLETON_H__

#include <iostream>
using namespace std;

/* 单例虚类
 * 将GC功能放在虚类中，子类无须考虑单例的释放问题，仅需继承该类即可。
 */
template<class C_T>
class ImplSingleton
{
public:
        virtual ~ImplSingleton() {
                cout << "~ImplSingleton" << endl;
        }

protected:
        ImplSingleton() {}

	/* 该方法仅测试使用，真正的单例对象，不需要显示执行free释放，
 	 * 使用了智能指针，应智能的管理内存。
	 */
        static void free()
        {
                // _gc.free();
        }

private:
        class GC            // 避免内存泄漏的垃圾回收(嵌套)类
        {
        public:
                ~GC()
                // void free()
                {
                        if (C_T::Get())
                        {
                                cout << "-----delete" << endl;
                                delete C_T::Get();
                        }
                }
        };
        static GC _gc; 
};

template<class C_T>
typename ImplSingleton<C_T>::GC ImplSingleton<C_T>::_gc;

#endif  // __IMPL_SINGLETON_H__

#ifndef __SINGLETON_REGISTER_H__
#define __SINGLETON_REGISTER_H__

/* 单例管理器
 * 1、进程唯一性；
 * 2、构造的单例对象，必须包含Get()全局接口，否则无法实例化
*/

// 可以得到函数 inline XXXX* GetXXXX();的定义
#define GET_SINGLETON_OBJECT_PTR(TypeName)                      \
        inline TypeName* Get##TypeName()                        \
        {                                                       \
                return SingletonRegister::Function<             \
                                        TypeName                \
                                        >::GetInstance();       \
        }

// 可以得到函数 inline XXXX& GetXXXX();的定义
#define GET_SINGLETON_OBJECT(TypeName)                          \
        inline TypeName& Get##TypeName()                        \
        {                                                       \
                return SingletonRegister::Function<             \
                                        TypeName                \
                                        >::GetInstanceObj();    \
        }

/* 单例构造器 */
class SingletonRegister
{
        /* 禁止拷贝构造(单例的唯一性) */
        SingletonRegister(const SingletonRegister&);
        SingletonRegister& operator=(const SingletonRegister&);
public:
        SingletonRegister() {}
        virtual ~SingletonRegister() {}

public:
        /* 单例构造函数，返回要构造的单例类型 */
        template <class Type>
        struct Function
        {
                /* 构造返回指针的构造函数 */
                static Type* GetInstance();

                /* 构造返回单例对象的构造函数 */
                static Type& GetInstanceObj();
        };

};

template<class Type>
Type* SingletonRegister::Function<Type>::GetInstance()
{
        return Type::GetInstance();
}

template<class Type>
Type& SingletonRegister::Function<Type>::GetInstanceObj()
{
        return Type::GetInstance();
}

#endif  // __SINGLETONS_REGISTER_H__

#include "WHPSStdioBase.h"

void vsprintfGet(char* buffer, const char* fmt, va_list& ap)
{
        if (buffer)
        {
                vsprintf(buffer, fmt, ap);
        }
}
#ifndef __WHPS_STDIO_BASE_H__
#define __WHPS_STDIO_BASE_H__

#include <stdio.h>

void vsprintfGet(char* buffer, const char* fmt, va_list& ap);

#endif  //
#include <string.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <time.h>

#include "WHPSLog.h"
#include "String.h"
#include "WHPSStdioBase.h"

using namespace std;

#define MAX_LEN 1024
bool debug_mode = true;

static void WHPSFlushToFile(const char* message);

static std::string MSG(const char* fmt, va_list& ap)
{
        string s_res;
        char* message = new char[1024];       // 1024大小先写死
        time_t timer = time(NULL);
        strftime(message, 23, "[%Y-%m-%d %H:%M:%S] ", localtime(&timer));

        if (fmt)
        {
                vsprintfGet(message+22, fmt, ap);
        }
        else
        {
                sprintf(message+22, "%s", va_arg(ap, const char*));
        }
        s_res = string(message);
        delete[] message;
        return s_res;
}

/* 外部无法实例化 */
class WHPSLog
{
public:
        WHPSLog();
        ~WHPSLog();

public:
        void printToFile(const std::string& msg);

private:
};

static WHPSLog whps_log;

void WHPSLogEventEx(int log_level, const char* fmt, va_list& va)
{
#ifndef __DEBUG__       // 非debug版本
        if (log_level == WHPSLOG_DEBUG)
        {
                return;
        }
#endif

        std::string msg = MSG(fmt, va);
        cout << msg << endl;
        whps_log.printToFile(msg);
}

WHPSLog::WHPSLog()
{

}

WHPSLog::~WHPSLog()
{

}

void WHPSLog::printToFile(const std::string& msg)
{
        WHPSFlushToFile((msg+"\n").c_str());
}

void WHPSFlushToFile(const char* message) 
{
        static bool print_time = true; //是否要打印时间: 当 debug_mode 为真，且上一次是换行符结尾。
        int fd = open("./log/test.log", O_WRONLY | O_CREAT | O_APPEND, S_IRUSR | S_IWUSR);

        if (fd == -1) {
                perror("open (log)");
        } else {
                if (print_time == false) {
                        if (write(fd, message + 22, strlen(message + 22)) == -1)
                        {
                                perror("lprintf");
                        }
                } else {
                        if (write(fd, message, strlen(message)) == -1)
                        {
                                perror("lprintf");
                        }
                }

                print_time = (message[strlen(message) - 1] == '\n');
                close(fd);
        }
}

#ifndef __WHPS_LOG_H__
#define __WHPS_LOG_H__

#include <stdarg.h>
#include <string>

enum LogLevel
{
        WHPSLOG_TRACE = 0,      // 基本不需要这个级别
        WHPSLOG_DEBUG,
        WHPSLOG_INFO,
        WHPSLOG_WARN,
        WHPSLOG_ERROR,
        WHPSLOG_CRITICAL,
        WHPSLOG_FATAL
};

void WHPSLogEventEx(int log_level, const char* fmt, va_list& va);

/* 抽象日志事件接口
 * 通过该接口，可以定义多个日志级别对应的函数
 */
#define IMPL_WHPSLogEvent_(log_level)                                   \
        inline void WHPSLogEvent_##log_level(const char* fmt, ...)      \
        {                                                               \
                va_list va;                                             \
                va_start(va, fmt);                                      \
                WHPSLogEventEx(log_level, fmt, va);                     \
                va_end(va);                                             \
        }

IMPL_WHPSLogEvent_(WHPSLOG_DEBUG)
IMPL_WHPSLogEvent_(WHPSLOG_INFO)
IMPL_WHPSLogEvent_(WHPSLOG_WARN)
IMPL_WHPSLogEvent_(WHPSLOG_ERROR)
IMPL_WHPSLogEvent_(WHPSLOG_CRITICAL)
IMPL_WHPSLogEvent_(WHPSLOG_FATAL)

#define WHPSLogEvent(log_level, fmt, ...)    WHPSLogEvent_##log_level(fmt, __VA_ARGS__);

/* 日志记录函数的入口方法 */
#ifdef __DEBUG__
        #define WHPSLogDebug(fmt, ...)       WHPSLogEvent(WHPSLOG_DEBUG, fmt, __VA_ARGS__)
#else
        #define WHPSLogDebug(fmt, ...)       ((void)0)       // release版本不会打印Debug类型日志
#endif

#define WHPSLogInfo(fmt, ...)        WHPSLogEvent(WHPSLOG_INFO, fmt, __VA_ARGS__)
#define WHPSLogWarn(fmt, ...)        WHPSLogEvent(WHPSLOG_WARN, fmt, __VA_ARGS__)
#define WHPSLogError(fmt, ...)       WHPSLogEvent(WHPSLOG_ERROR, fmt, __VA_ARGS__)
#define WHPSLogCritical(fmt, ...)       WHPSLogEvent(WHPSLOG_CRITICAL, fmt, __VA_ARGS__)
#define WHPSLogFatal(fmt, ...)       WHPSLogEvent(WHPSLOG_FATAL, fmt, __VA_ARGS__)

#endif  // __WHPS_LOG_H__#ifndef __MAP_H__
#define __MAP_H__

#include <map>
#include <mutex>

/* 线程安全的map */
template<class __K, class __V>
class Map: public std::map<__K, __V> 
{
public:
        using iterator = typename Map<__K, __V>::iterator;
public:
        void insert(const __K& k, const __V& v)
        {
                std::lock_guard<std::mutex> lock(__mutex);
                std::map<__K, __V>::insert(std::pair<__K, __V>(k, v));
        }

        void erase(const __K& k)
        {
                std::lock_guard<std::mutex> lock(__mutex);
                std::map<__K, __V>::erase(k);
        }

        __V& operator[](const __K& k)
        {
                std::lock_guard<std::mutex> lock(__mutex);
                return std::map<__K, __V>::operator[](k);
        }

        size_t size()
        {
                std::lock_guard<std::mutex> lock(__mutex);
                return std::map<__K, __V>::size();
        }

        iterator find(const __K& k)
        {
                std::lock_guard<std::mutex> lock(__mutex);
                return std::map<__K, __V>::find(k);
        }

        const __V& at(const __K& k)
        {
                std::lock_guard<std::mutex> lock(__mutex);
                return std::map<__K, __V>::at(k);
        }

        void swap(std::map<__K, __V> x)
        {
                std::lock_guard<std::mutex> lock(__mutex);
                std::map<__K, __V>::swap(x);
        }
private:
        std::mutex __mutex;
};

#endif  // __MAP_H__
/*
 * String.cpp
 *
 *  Created on: Oct 10, 2018
 *      Author: wenhan
 */

#include <vector>
#include <iostream>

#include <string.h>

#include "String.h"

using namespace std;

String::String()
{

}

String::String(const string& str)
        : _str(str)
{

}

String::~String()
{

}

const string& String::str() const
{
        return _str;
}

string String::Str() const
{
        return _str;
}

String::SVector String::splitOnce(const char* sep)
{
        SVector v;
        size_t pos = 0;
        string s1 = _str;

        pos = s1.find(sep);
        if (pos != string::npos) 
        {
                const string& s = s1.substr(0, pos);
                v.push_back(s);
                s1 = s1.substr(pos + strlen(sep), _str.size());
                v.push_back(s1);
        }

        return v;
}

String::SVector String::split(const char* sep)
{
        SVector v;
        size_t pos = 0;
        string s1 = _str;

        while ((pos = s1.find(sep)) != string::npos) {
                const string& s = s1.substr(0, pos);
                v.push_back(s);
                s1 = s1.substr(pos + strlen(sep), _str.size());
        }

        v.push_back(s1);

        return v;
}

void String::strip()
{
        for (size_t i = 0; (i = _str.find(' ')) != std::string::npos;) {
                _str.replace(i, 1, "");
        }
}

void String::strip(const char* chr)
{
        for (size_t i = 0; (i = _str.find(chr)) != std::string::npos;) {
                _str.replace(i, 1, "");
        }
}

void String::replace(const string& src, const string& des)
{
        size_t pos = _str.find(src);

        if (pos != string::npos) {
                _str.replace(pos, src.size(), des);
        }
}

void String::replaceAll(const std::string& src, const std::string& des)
{
        for (size_t i = 0; (i = _str.find(src)) != std::string::npos;) {
                _str.replace(i, src.size(), des);
        }
}

void String::operator=(const string s)
{
        _str = s;
}

void String::operator=(const char* s)
{
        _str = string(s);
}

size_t String::count(const std::string& sub)
{
        size_t size = 0;

        for (size_t i = 0; (i = _str.find(sub, i)) != std::string::npos; i++) {
                size++;
        }

        return size;
}

size_t String::find(const char& c)
{
        return _str.find(c);
}

size_t String::size()
{
        return _str.size();
}

bool String::matchCase(const char* c)
{
        return _str.find(c) != string::npos;
}

const string& String::encode(const string& type)
{
        _str = Codec::encode(_str, type);

        return _str;
}
        
const string& String::decode(const string& type)
{
        _str = Codec::decode(_str, type);

        return _str;
}/*
 * String.h
 *
 *  Created on: Oct 10, 2018
 *      Author: wenhan
 */

#ifndef STRING_H_
#define STRING_H_

#include <vector>
#include <string>
#include <iostream>

#include "Codec.h"

class String: public std::string 
{
public:
        typedef std::vector<std::string> SVector;

        String();
        String(const std::string& str);

        ~String();

        /* 获取字符串 */
        const std::string& str() const;
        std::string Str() const;

        /* 按照sep拆分字符串(仅拆分一次) */
        SVector splitOnce(const char* sep);

        /* 按照sep拆分字符串 */
        SVector split(const char* sep);

    	/* 默认过滤字符串中的空格 */
    	void strip();

        /* 过滤字符串中，带有chr的字符 */
        void strip(const char* chr);

        /* 使用des替换src，仅匹配一次 */
        void replace(const std::string& src, const std::string& des);

        /* 使用des替换src，匹配所有 */
        void replaceAll(const std::string& src, const std::string& des);

        /* 运算符重载，拷贝构造 string类型 */
        void operator=(const std::string s);

        /* 运算符重载，拷贝构造 char[]类型*/
        void operator=(const char* s);

        /* 统计子字符串出现的次数 */
        size_t count(const std::string& sub);

        size_t find(const char& c);

        size_t size();

        /* 判断字符子串是否在String中存在 */
        bool matchCase(const char* c);

        /* 字符串编码
         */
        const std::string& encode(const std::string& type = "utf-8");
        
        /* 字符串解码
         */
        const std::string& decode(const std::string& type = "utf-8");
private:
        std::string _str;
};

typedef String::SVector SVector;

#endif /* STRING_H_ */

#ifndef __VECTOR_H__
#define __VECTOR_H__

#include <vector>
#include <mutex>

/* 线程安全的vector */
template <class __T>
class Vector : public std::vector<__T>
{
public:
        using value_type = typename std::vector<__T>::value_type;
        using size_type  = typename std::vector<__T>::size_type;
public:
        explicit Vector()
                : std::vector<__T>()
        {

        }

        explicit Vector(size_type n)
                : std::vector<__T>(n)
        {

        }

        void push_back(const value_type& v)
        {
                std::lock_guard<std::mutex> lock(__mutex);
                std::vector<__T>::push_back(v);
        }

        __T& operator[](size_type i)
        {
                std::lock_guard<std::mutex> lock(__mutex);
                return std::vector<__T>::operator[](i);
        }

        size_type capacity()
        {
                std::lock_guard<std::mutex> lock(__mutex);
                return std::vector<__T>::capacity();
        }
private:
        std::mutex __mutex;
};

#endif  // __VECTOR_H__